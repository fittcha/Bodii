{
  "file_path": "Bodii/Data/DataSources/Local/FoodLocalDataSource.swift",
  "main_branch_history": [],
  "task_views": {
    "005-korean-food-database-integration": {
      "task_id": "005-korean-food-database-integration",
      "branch_point": {
        "commit_hash": "c44bfbcd7c1699b176a8bb155e8c35f43ebd4ad9",
        "content": "",
        "timestamp": "2026-01-13T07:46:23.878686"
      },
      "worktree_state": {
        "content": "//\n//  FoodLocalDataSource.swift\n//  Bodii\n//\n//  Created by Auto-Claude on 2026-01-13.\n//\n\n// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Local Data Source Implementation\n// Core Data\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub85c\uceec \uce90\uc2dc\ub97c \uad00\ub9ac\ud558\ub294 \ub370\uc774\ud130 \uc18c\uc2a4\n// \ud83d\udca1 Java \ube44\uad50: JPA Repository\uc758 \uad6c\ud604\uccb4\uc640 \uc720\uc0ac\n\nimport Foundation\nimport CoreData\n\n/// \uc2dd\ud488 \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4 \uad6c\ud604\uccb4\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Local Data Source Pattern\n/// Core Data\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc2dd\ud488 \uc815\ubcf4\ub97c \ub85c\uceec\uc5d0 \uce90\uc2f1\ud558\uace0 \uad00\ub9ac\ud569\ub2c8\ub2e4.\n/// API \uac80\uc0c9 \uacb0\uacfc\ub97c \uce90\uc2f1\ud558\uc5ec \uc624\ud504\ub77c\uc778 \uc811\uadfc\uacfc \ube60\ub978 \uc7ac\uac80\uc0c9\uc744 \uc9c0\uc6d0\ud569\ub2c8\ub2e4.\n/// \ud83d\udca1 Java \ube44\uad50: JPA\ub97c \uc0ac\uc6a9\ud55c \ub85c\uceec DB \uc811\uadfc \ub808\uc774\uc5b4\uc640 \uc720\uc0ac\n///\n/// **\uc544\ud0a4\ud14d\ucc98:**\n/// ```\n/// FoodSearchRepositoryImpl\n///        \u2193\n/// FoodLocalDataSource (Implementation) \u2190 Data Layer\n///        \u2193\n/// Core Data (FoodEntity) \u2190 Infrastructure Layer\n/// ```\n///\n/// **\uce90\uc2f1 \uc804\ub7b5:**\n/// - LRU (Least Recently Used): lastAccessedAt \uae30\uc900\n/// - \uc778\uae30\ub3c4 \ucd94\uc801: searchCount\ub85c \uc778\uae30 \uc2dd\ud488 \ud30c\uc545\n/// - \uc790\ub3d9 \ub9cc\ub8cc: 30\uc77c \uc774\uc0c1 \ub41c \uce90\uc2dc \uc790\ub3d9 \uc815\ub9ac\n/// - \uc911\ubcf5 \ubc29\uc9c0: apiCode\ub85c \uc911\ubcf5 \uc800\uc7a5 \ubc29\uc9c0\n///\n/// **\uc8fc\uc694 \uae30\ub2a5:**\n/// - \uc2dd\ud488 \uac80\uc0c9 (\uc774\ub984 \uae30\ubc18 \ubd80\ubd84 \ub9e4\uce6d)\n/// - \ucd5c\uadfc \uac80\uc0c9 \uc2dd\ud488 \uc870\ud68c (LRU)\n/// - \uc2dd\ud488 \uc800\uc7a5 (\uc911\ubcf5 \uccb4\ud06c \ud3ec\ud568)\n/// - \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8 (LRU \uce90\uc2dc \uc720\uc9c0)\n/// - \uc624\ub798\ub41c \uce90\uc2dc \uc815\ub9ac (\uc800\uc7a5 \uacf5\uac04 \ucd5c\uc801\ud654)\n///\n/// **\uc0ac\uc6a9 \uc608\uc2dc:**\n/// ```swift\n/// let dataSource = FoodLocalDataSourceImpl()\n///\n/// // \uce90\uc2dc\uc5d0 \uc800\uc7a5\n/// try await dataSource.saveFoods(foods)\n///\n/// // \uce90\uc2dc\uc5d0\uc11c \uac80\uc0c9\n/// let results = try await dataSource.searchFoods(query: \"\uae40\uce58\", limit: 20)\n///\n/// // \ucd5c\uadfc \uac80\uc0c9 \uc2dd\ud488\n/// let recent = try await dataSource.getRecentFoods(limit: 10)\n/// ```\nfinal class FoodLocalDataSourceImpl: FoodLocalDataSource {\n\n    // MARK: - Properties\n\n    /// Core Data \ucee8\ud14d\uc2a4\ud2b8\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: NSManagedObjectContext\n    /// Core Data \uc791\uc5c5\uc758 \ud575\uc2ec - \uc5d4\ud2f0\ud2f0 \uc0dd\uc131, \uc870\ud68c, \uc218\uc815, \uc0ad\uc81c \uad00\ub9ac\n    /// \ud83d\udca1 Java \ube44\uad50: JPA\uc758 EntityManager\uc640 \uc720\uc0ac\ud55c \uc5ed\ud560\n    private let context: NSManagedObjectContext\n\n    /// \uae30\ubcf8 \uce90\uc2dc \ud06c\uae30 \uc81c\ud55c\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: \uce90\uc2dc \uc0ac\uc774\uc988 \uc81c\ud55c\n    /// \ubb34\ud55c\uc815 \uc99d\uac00\ub97c \ubc29\uc9c0\ud558\uc5ec \uc800\uc7a5 \uacf5\uac04\uacfc \uc131\ub2a5 \ucd5c\uc801\ud654\n    /// \ud83d\udca1 500\uac1c = \uc57d 50KB (\uc5d4\ud2f0\ud2f0\ub2f9 100B \uac00\uc815)\n    private let defaultMaxCacheSize = 500\n\n    // MARK: - Initialization\n\n    /// FoodLocalDataSourceImpl \ucd08\uae30\ud654\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Dependency Injection\n    /// PersistenceController\ub97c \uc8fc\uc785\ubc1b\uc544 \ud14c\uc2a4\ud2b8 \uc2dc mock\uc73c\ub85c \uad50\uccb4 \uac00\ub2a5\n    /// \ud83d\udca1 Java \ube44\uad50: @Autowired EntityManager injection\n    ///\n    /// - Parameter persistenceController: Core Data \ucee8\ud2b8\ub864\ub7ec (\uae30\ubcf8\uac12: shared)\n    init(persistenceController: PersistenceController = .shared) {\n        self.context = persistenceController.viewContext\n    }\n\n    // MARK: - FoodLocalDataSource Protocol Implementation\n\n    /// \uce90\uc2dc\uc5d0\uc11c \uc2dd\ud488 \uac80\uc0c9\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Name-Based Search\n    /// Core Data\uc758 NSPredicate\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc774\ub984 \uae30\ubc18 \ubd80\ubd84 \ub9e4\uce6d \uac80\uc0c9\n    /// CONTAINS[cd]: \ub300\uc18c\ubb38\uc790/\ubc1c\uc74c \uad6c\ubcc4 \uc5c6\uc774 \uac80\uc0c9\n    /// \ud83d\udca1 Java \ube44\uad50: JPA\uc758 LIKE \ucffc\ub9ac\uc640 \uc720\uc0ac (%keyword%)\n    ///\n    /// - Parameters:\n    ///   - query: \uac80\uc0c9\uc5b4 (\uc2dd\ud488\uba85)\n    ///   - limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218\n    ///\n    /// - Returns: \uac80\uc0c9\ub41c \uc2dd\ud488 \ubc30\uc5f4 (searchCount \uae30\uc900 \uc815\ub82c)\n    ///\n    /// - Throws: `FoodLocalDataSourceError.fetchFailed`: \uc870\ud68c \uc2e4\ud328\n    func searchFoods(query: String, limit: Int) async throws -> [Food] {\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Async/Await with Core Data\n        // Core Data\ub294 \ub3d9\uae30 API\uc774\ubbc0\ub85c Task\ub97c \uc0ac\uc6a9\ud558\uc5ec \ube44\ub3d9\uae30\ub85c \ub798\ud551\n        // \ud83d\udca1 Java \ube44\uad50: CompletableFuture\ub85c \ub3d9\uae30 \uc791\uc5c5\uc744 \ube44\ub3d9\uae30\ud654\ud558\ub294 \uac83\uacfc \uc720\uc0ac\n        return try await context.perform {\n            do {\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Fetch Request with Predicate\n                // FoodEntity+CoreData\uc758 \ud655\uc7a5 \uba54\uc11c\ub4dc \uc0ac\uc6a9\n                let request = Food.fetchByName(query, limit: limit)\n                let foodEntities = try self.context.fetch(request)\n\n                #if DEBUG\n                print(\"\u2705 [FoodLocalDataSource] Found \\(foodEntities.count) foods for query '\\(query)'\")\n                #endif\n\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Entity to Domain Conversion\n                // Core Data \uc5d4\ud2f0\ud2f0\ub97c Domain \uc5d4\ud2f0\ud2f0\ub85c \ubcc0\ud658\n                // \ud83d\udca1 Java \ube44\uad50: JPA Entity \u2192 DTO \ubcc0\ud658\uacfc \uc720\uc0ac\n                return try foodEntities.map { try $0.toDomainEntity() }\n\n            } catch let error as FoodEntityError {\n                // Core Data \uc5d4\ud2f0\ud2f0 \uc5d0\ub7ec\ub97c \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4 \uc5d0\ub7ec\ub85c \ubcc0\ud658\n                throw FoodLocalDataSourceError.conversionFailed(error.localizedDescription)\n            } catch {\n                // \uae30\ud0c0 \uc5d0\ub7ec (fetch \uc2e4\ud328 \ub4f1)\n                throw FoodLocalDataSourceError.fetchFailed(error)\n            }\n        }\n    }\n\n    /// \ucd5c\uadfc \uac80\uc0c9\ud55c \uc2dd\ud488 \uc870\ud68c\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: LRU (Least Recently Used) Cache\n    /// lastAccessedAt \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud558\uc5ec \ucd5c\uadfc \uc811\uadfc\ud55c \uc2dd\ud488 \uc6b0\uc120 \ubc18\ud658\n    /// \ud83d\udca1 Java \ube44\uad50: LinkedHashMap\uc758 access-order mode\uc640 \uc720\uc0ac\n    ///\n    /// - Parameter limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218 (\uae30\ubcf8\uac12: 20)\n    ///\n    /// - Returns: \ucd5c\uadfc \uac80\uc0c9\ud55c \uc2dd\ud488 \ubc30\uc5f4 (lastAccessedAt \ub0b4\ub9bc\ucc28\uc21c)\n    ///\n    /// - Throws: `FoodLocalDataSourceError.fetchFailed`: \uc870\ud68c \uc2e4\ud328\n    func getRecentFoods(limit: Int) async throws -> [Food] {\n        return try await context.perform {\n            do {\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Pre-defined Fetch Request\n                // FoodEntity+CoreData\uc758 fetchRecentFoods() \uba54\uc11c\ub4dc \uc0ac\uc6a9\n                let request = Food.fetchRecentFoods(limit: limit)\n                let foodEntities = try self.context.fetch(request)\n\n                #if DEBUG\n                print(\"\u2705 [FoodLocalDataSource] Retrieved \\(foodEntities.count) recent foods\")\n                #endif\n\n                return try foodEntities.map { try $0.toDomainEntity() }\n\n            } catch let error as FoodEntityError {\n                throw FoodLocalDataSourceError.conversionFailed(error.localizedDescription)\n            } catch {\n                throw FoodLocalDataSourceError.fetchFailed(error)\n            }\n        }\n    }\n\n    /// \uc2dd\ud488 \uc800\uc7a5 (\uc911\ubcf5 \uccb4\ud06c \ud3ec\ud568)\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Upsert Pattern (Update or Insert)\n    /// apiCode\ub85c \uae30\uc874 \ub370\uc774\ud130 \ud655\uc778 \ud6c4 \uc5c5\ub370\uc774\ud2b8 \ub610\ub294 \uc0bd\uc785\n    /// \ud83d\udca1 Java \ube44\uad50: JPA\uc758 merge() \ub610\ub294 @Entity\uc758 @Id \uae30\ubc18 upsert\n    ///\n    /// - Parameter foods: \uc800\uc7a5\ud560 \uc2dd\ud488 \ubc30\uc5f4\n    ///\n    /// - Throws: `FoodLocalDataSourceError.saveFailed`: \uc800\uc7a5 \uc2e4\ud328\n    func saveFoods(_ foods: [Food]) async throws {\n        guard !foods.isEmpty else {\n            #if DEBUG\n            print(\"\u2139\ufe0f [FoodLocalDataSource] No foods to save\")\n            #endif\n            return\n        }\n\n        try await context.perform {\n            do {\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Batch Insert with Deduplication\n                // FoodEntity+CoreData\uc758 saveUnique() \uba54\uc11c\ub4dc \uc0ac\uc6a9\n                // apiCode \uae30\uc900\uc73c\ub85c \uc911\ubcf5 \uccb4\ud06c \ud6c4 upsert\n                let savedCount = try Food.saveUnique(from: foods, context: self.context)\n\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Context Save\n                // Core Data\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc744 \uba54\ubaa8\ub9ac\uc5d0 \uc800\uc7a5 \u2192 save() \ud638\ucd9c \uc2dc \ub514\uc2a4\ud06c\uc5d0 \uae30\ub85d\n                // \ud83d\udca1 Java \ube44\uad50: EntityManager.flush()\uc640 \uc720\uc0ac\n                if self.context.hasChanges {\n                    try self.context.save()\n                }\n\n                #if DEBUG\n                print(\"\u2705 [FoodLocalDataSource] Saved \\(savedCount) new foods (total: \\(foods.count))\")\n                #endif\n\n            } catch {\n                throw FoodLocalDataSourceError.saveFailed(error)\n            }\n        }\n    }\n\n    /// \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Activity Tracking for LRU\n    /// \uc0ac\uc6a9\uc790\uac00 \uc2dd\ud488\uc744 \uc120\ud0dd\ud560 \ub54c\ub9c8\ub2e4 \ud638\ucd9c\ud558\uc5ec \ucd5c\uadfc \uc811\uadfc \uc2dc\uac04 \uac31\uc2e0\n    /// LRU \uce90\uc2dc \uc815\ucc45\uc5d0 \ud65c\uc6a9\n    /// \ud83d\udca1 Java \ube44\uad50: Cache.get()\uc5d0\uc11c \uc790\ub3d9\uc73c\ub85c access time \uc5c5\ub370\uc774\ud2b8\ud558\ub294 \uac83\uacfc \uc720\uc0ac\n    ///\n    /// - Parameter foodId: \uc2dd\ud488 \uace0\uc720 ID\n    ///\n    /// - Throws: `FoodLocalDataSourceError.updateFailed`: \uc5c5\ub370\uc774\ud2b8 \uc2e4\ud328\n    func updateAccessTime(foodId: UUID) async throws {\n        try await context.perform {\n            do {\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Fetch by Primary Key\n                // UUID\ub85c \ud2b9\uc815 \uc5d4\ud2f0\ud2f0 \uc870\ud68c\n                let request: NSFetchRequest<Food> = Food.fetchRequest()\n                request.predicate = NSPredicate(format: \"id == %@\", foodId as CVarArg)\n                request.fetchLimit = 1\n\n                guard let foodEntity = try self.context.fetch(request).first else {\n                    #if DEBUG\n                    print(\"\u2139\ufe0f [FoodLocalDataSource] Food not found: \\(foodId)\")\n                    #endif\n                    // \uc2dd\ud488\uc774 \uc5c6\uc5b4\ub3c4 \uc5d0\ub7ec\ub294 \uc544\ub2d8 (\uce90\uc2dc\uc5d0 \uc5c6\uc744 \uc218 \uc788\uc74c)\n                    return\n                }\n\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Entity Update\n                // FoodEntity+CoreData\uc758 updateAccessTime() \uba54\uc11c\ub4dc \uc0ac\uc6a9\n                // lastAccessedAt = \ud604\uc7ac \uc2dc\uac04, searchCount += 1\n                foodEntity.updateAccessTime()\n\n                if self.context.hasChanges {\n                    try self.context.save()\n                }\n\n                #if DEBUG\n                print(\"\u2705 [FoodLocalDataSource] Updated access time for: \\(foodEntity.name ?? \"unknown\")\")\n                #endif\n\n            } catch {\n                throw FoodLocalDataSourceError.updateFailed(error)\n            }\n        }\n    }\n\n    /// \uc624\ub798\ub41c \uce90\uc2dc \uc815\ub9ac\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Cache Eviction Policy\n    /// LRU \uc815\ucc45\uc73c\ub85c \uce90\uc2dc \ud06c\uae30 \uc81c\ud55c - \ucd5c\uadfc \uc811\uadfc\ud558\uc9c0 \uc54a\uc740 \ud56d\ubaa9 \uc0ad\uc81c\n    /// \ud83d\udca1 Java \ube44\uad50: LinkedHashMap.removeEldestEntry()\uc640 \uc720\uc0ac\n    ///\n    /// **\uc815\ub9ac \uc804\ub7b5:**\n    /// 1. \ub9cc\ub8cc\ub41c \uce90\uc2dc \uc0ad\uc81c (30\uc77c \uc774\uc0c1 \ub41c API \ub370\uc774\ud130)\n    /// 2. \ucd5c\ub300 \ud06c\uae30 \ucd08\uacfc \uc2dc LRU\ub85c \ucd94\uac00 \uc0ad\uc81c\n    ///\n    /// - Parameter maxCount: \uce90\uc2dc \ucd5c\ub300 \ud06c\uae30 (\uae30\ubcf8\uac12: 500)\n    ///\n    /// - Throws: `FoodLocalDataSourceError.deleteFailed`: \uc0ad\uc81c \uc2e4\ud328\n    func cleanupOldFoods(maxCount: Int) async throws {\n        let targetMaxCount = maxCount > 0 ? maxCount : defaultMaxCacheSize\n\n        try await context.perform {\n            do {\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: 1\ub2e8\uacc4 - \ub9cc\ub8cc\ub41c \uce90\uc2dc \uc0ad\uc81c\n                // 30\uc77c \uc774\uc0c1 \ub41c API \ub370\uc774\ud130 \uc790\ub3d9 \uc0ad\uc81c\n                let expiredRequest = Food.fetchExpiredCache(days: 30)\n                let expiredFoods = try self.context.fetch(expiredRequest)\n\n                var deletedCount = 0\n                for food in expiredFoods {\n                    self.context.delete(food)\n                    deletedCount += 1\n                }\n\n                #if DEBUG\n                if deletedCount > 0 {\n                    print(\"\ud83d\uddd1\ufe0f [FoodLocalDataSource] Deleted \\(deletedCount) expired foods\")\n                }\n                #endif\n\n                // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: 2\ub2e8\uacc4 - LRU \uae30\ubc18 \ucd94\uac00 \uc815\ub9ac\n                // \ucd5c\ub300 \ud06c\uae30 \ucd08\uacfc \uc2dc \uc624\ub798\ub41c \ud56d\ubaa9\ubd80\ud130 \uc0ad\uc81c\n                let countRequest: NSFetchRequest<Food> = Food.fetchRequest()\n                let totalCount = try self.context.count(for: countRequest)\n\n                if totalCount > targetMaxCount {\n                    // \uac00\uc7a5 \uc624\ub798\ub41c \ud56d\ubaa9\ubd80\ud130 \uc0ad\uc81c (lastAccessedAt \uc624\ub984\ucc28\uc21c)\n                    let excessCount = totalCount - targetMaxCount\n                    let oldestRequest: NSFetchRequest<Food> = Food.fetchRequest()\n                    oldestRequest.sortDescriptors = [NSSortDescriptor(key: \"lastAccessedAt\", ascending: true)]\n                    oldestRequest.fetchLimit = excessCount\n\n                    let oldestFoods = try self.context.fetch(oldestRequest)\n                    for food in oldestFoods {\n                        self.context.delete(food)\n                        deletedCount += 1\n                    }\n\n                    #if DEBUG\n                    print(\"\ud83d\uddd1\ufe0f [FoodLocalDataSource] Deleted \\(excessCount) oldest foods (LRU)\")\n                    #endif\n                }\n\n                // \ubcc0\uacbd\uc0ac\ud56d \uc800\uc7a5\n                if self.context.hasChanges {\n                    try self.context.save()\n                }\n\n                #if DEBUG\n                let finalCount = try self.context.count(for: countRequest)\n                print(\"\u2705 [FoodLocalDataSource] Cache cleanup completed (deleted: \\(deletedCount), remaining: \\(finalCount))\")\n                #endif\n\n            } catch {\n                throw FoodLocalDataSourceError.deleteFailed(error)\n            }\n        }\n    }\n}\n\n// MARK: - FoodLocalDataSource Error\n\n/// \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4 \uc5d0\ub7ec\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Custom Error Types\n/// \uac01 \uc791\uc5c5\ubcc4\ub85c \uad6c\uccb4\uc801\uc778 \uc5d0\ub7ec \ud0c0\uc785 \uc815\uc758\n/// \ud83d\udca1 Java \ube44\uad50: Custom Exception \ud074\ub798\uc2a4\uc640 \uc720\uc0ac\nenum FoodLocalDataSourceError: Error {\n    case fetchFailed(Error)\n    case saveFailed(Error)\n    case updateFailed(Error)\n    case deleteFailed(Error)\n    case conversionFailed(String)\n\n    /// \uc0ac\uc6a9\uc790\uc5d0\uac8c \ud45c\uc2dc\ud560 \uc5d0\ub7ec \uba54\uc2dc\uc9c0\n    var localizedDescription: String {\n        switch self {\n        case .fetchFailed(let error):\n            return \"\uce90\uc2dc \uc870\ud68c\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4: \\(error.localizedDescription)\"\n        case .saveFailed(let error):\n            return \"\uce90\uc2dc \uc800\uc7a5\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4: \\(error.localizedDescription)\"\n        case .updateFailed(let error):\n            return \"\uce90\uc2dc \uc5c5\ub370\uc774\ud2b8\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4: \\(error.localizedDescription)\"\n        case .deleteFailed(let error):\n            return \"\uce90\uc2dc \uc0ad\uc81c\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4: \\(error.localizedDescription)\"\n        case .conversionFailed(let message):\n            return \"\ub370\uc774\ud130 \ubcc0\ud658\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4: \\(message)\"\n        }\n    }\n}\n\n// MARK: - Testing Support\n\n#if DEBUG\n/// \ud14c\uc2a4\ud2b8\uc6a9 Mock FoodLocalDataSource\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Mock Data Source for Testing\n/// \ud14c\uc2a4\ud2b8\uc5d0\uc11c \uc2e4\uc81c Core Data \uc5c6\uc774 \ub3d9\uc791 \uac80\uc99d \uac00\ub2a5\n/// \ud83d\udca1 Java \ube44\uad50: Mockito\uc758 @Mock\uc640 \uc720\uc0ac\nfinal class MockFoodLocalDataSource: FoodLocalDataSource {\n\n    /// Mock \uc800\uc7a5\uc18c\n    private var mockStorage: [UUID: Food] = [:]\n\n    /// \uc5d0\ub7ec \uc2dc\ubbac\ub808\uc774\uc158\n    var shouldThrowError: Error?\n\n    /// \ud638\ucd9c \ucd94\uc801\n    var searchCallCount = 0\n    var getRecentCallCount = 0\n    var saveCallCount = 0\n    var updateAccessTimeCallCount = 0\n    var cleanupCallCount = 0\n\n    func searchFoods(query: String, limit: Int) async throws -> [Food] {\n        searchCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        // \uc774\ub984\uc5d0 \uac80\uc0c9\uc5b4\uac00 \ud3ec\ud568\ub41c \uc2dd\ud488 \ud544\ud130\ub9c1\n        let results = mockStorage.values.filter { food in\n            food.name.localizedCaseInsensitiveContains(query)\n        }\n\n        return Array(results.prefix(limit))\n    }\n\n    func getRecentFoods(limit: Int) async throws -> [Food] {\n        getRecentCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        // Mock: \uc800\uc7a5\ub41c \ubaa8\ub4e0 \uc2dd\ud488 \ubc18\ud658\n        return Array(mockStorage.values.prefix(limit))\n    }\n\n    func saveFoods(_ foods: [Food]) async throws {\n        saveCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        // Mock \uc800\uc7a5\uc18c\uc5d0 \ucd94\uac00\n        for food in foods {\n            mockStorage[food.id] = food\n        }\n    }\n\n    func updateAccessTime(foodId: UUID) async throws {\n        updateAccessTimeCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        // Mock: \uc544\ubb34 \uc791\uc5c5\ub3c4 \ud558\uc9c0 \uc54a\uc74c\n    }\n\n    func cleanupOldFoods(maxCount: Int) async throws {\n        cleanupCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        // Mock: \ucd08\uacfc\ubd84 \uc0ad\uc81c\n        if mockStorage.count > maxCount {\n            let excessCount = mockStorage.count - maxCount\n            let keysToRemove = Array(mockStorage.keys.prefix(excessCount))\n            for key in keysToRemove {\n                mockStorage.removeValue(forKey: key)\n            }\n        }\n    }\n\n    /// \ud14c\uc2a4\ud2b8 \ud5ec\ud37c: Mock \uc800\uc7a5\uc18c \ucd08\uae30\ud654\n    func reset() {\n        mockStorage.removeAll()\n        shouldThrowError = nil\n        searchCallCount = 0\n        getRecentCallCount = 0\n        saveCallCount = 0\n        updateAccessTimeCallCount = 0\n        cleanupCallCount = 0\n    }\n\n    /// \ud14c\uc2a4\ud2b8 \ud5ec\ud37c: Mock \uc800\uc7a5\uc18c\uc5d0 \uc2dd\ud488 \ucd94\uac00\n    func addMockFood(_ food: Food) {\n        mockStorage[food.id] = food\n    }\n}\n#endif\n",
        "last_modified": "2026-01-14T22:55:39.260655"
      },
      "task_intent": {
        "title": "005-korean-food-database-integration",
        "description": "Integrate Korean Food & Drug Administration (\uc2dd\uc57d\ucc98) food nutrition database API as primary source, with USDA FoodData Central as fallback for international foods. Prioritize Korean dishes (kimchi jjigae, bibimbap, tteokbokki) that are poorly covered by competitors.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T07:43:31.620626",
  "last_updated": "2026-01-13T07:46:24.024593"
}