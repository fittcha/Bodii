{
  "file_path": "BodiiTests/Services/UnifiedFoodSearchServiceTests.swift",
  "main_branch_history": [],
  "task_views": {
    "005-korean-food-database-integration": {
      "task_id": "005-korean-food-database-integration",
      "branch_point": {
        "commit_hash": "c44bfbcd7c1699b176a8bb155e8c35f43ebd4ad9",
        "content": "",
        "timestamp": "2026-01-13T07:46:23.878686"
      },
      "worktree_state": {
        "content": "//\n//  UnifiedFoodSearchServiceTests.swift\n//  BodiiTests\n//\n//  Created by Auto-Claude on 2026-01-13.\n//\n\nimport XCTest\n@testable import Bodii\n\n/// Unit tests for UnifiedFoodSearchService\n///\n/// UnifiedFoodSearchService\uc758 \uac80\uc0c9 \uc6b0\uc120\uc21c\uc704, \ud3f4\ubc31, \uc5d0\ub7ec \ucc98\ub9ac \ub2e8\uc704 \ud14c\uc2a4\ud2b8\n///\n/// **\ud14c\uc2a4\ud2b8 \ubc94\uc704:**\n/// - Korean query prioritization (\uc2dd\uc57d\ucc98 \uc6b0\uc120)\n/// - USDA fallback when KFDA returns empty or insufficient results\n/// - Concurrent search for English queries\n/// - Deduplication logic\n/// - Error handling and retry logic\n/// - Edge cases and boundary conditions\nfinal class UnifiedFoodSearchServiceTests: XCTestCase {\n\n    // MARK: - Properties\n\n    var service: UnifiedFoodSearchService!\n    var mockKFDAService: MockKFDAFoodAPIService!\n    var mockUSDAService: MockUSDAFoodAPIService!\n\n    // MARK: - Setup & Teardown\n\n    override func setUp() {\n        super.setUp()\n\n        // Initialize mock services\n        mockKFDAService = MockKFDAFoodAPIService()\n        mockUSDAService = MockUSDAFoodAPIService()\n\n        // Initialize service with mocks\n        service = UnifiedFoodSearchService(\n            kfdaService: mockKFDAService,\n            usdaService: mockUSDAService\n        )\n    }\n\n    override func tearDown() {\n        service = nil\n        mockKFDAService = nil\n        mockUSDAService = nil\n        super.tearDown()\n    }\n\n    // MARK: - Korean Query Tests (\uc2dd\uc57d\ucc98 \uc6b0\uc120)\n\n    /// Test: Korean query searches KFDA first and returns KFDA results if sufficient\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ud55c\uae00 \uac80\uc0c9\uc5b4\ub294 \uc2dd\uc57d\ucc98 \uba3c\uc800 \uac80\uc0c9\ud558\uace0 \uacb0\uacfc\uac00 \ucda9\ubd84\ud558\uba74 \uc2dd\uc57d\ucc98 \uacb0\uacfc\ub9cc \ubc18\ud658\n    func testSearchFoods_KoreanQuery_SufficientKFDAResults_ReturnsOnlyKFDA() async throws {\n        // Given: Korean query with sufficient KFDA results (\u22655)\n        let kfdaFoods = createSampleKFDAFoods(count: 10)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        // USDA service should not be called\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: [])\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\uae40\uce58\ucc0c\uac1c\", limit: 20)\n\n        // Then: Should return KFDA results only\n        XCTAssertEqual(results.count, 10, \"Should return 10 KFDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called once\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 0, \"USDA should not be called\")\n\n        // Verify all results are from KFDA\n        for food in results {\n            XCTAssertEqual(food.source, .governmentAPI, \"All foods should be from governmentAPI\")\n        }\n    }\n\n    /// Test: Korean query searches USDA as fallback when KFDA returns insufficient results\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ud55c\uae00 \uac80\uc0c9\uc5b4\uc5d0 \uc2dd\uc57d\ucc98 \uacb0\uacfc\uac00 \ubd80\uc871\ud558\uba74 USDA\ub3c4 \uac80\uc0c9\ud558\uc5ec \ucd94\uac00\n    func testSearchFoods_KoreanQuery_InsufficientKFDAResults_FallsBackToUSDA() async throws {\n        // Given: Korean query with insufficient KFDA results (<5)\n        let kfdaFoods = createSampleKFDAFoods(count: 3)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = createSampleUSDAFoods(count: 7)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 20)\n\n        // Then: Should return both KFDA and USDA results\n        XCTAssertEqual(results.count, 10, \"Should return 3 KFDA + 7 USDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called once\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 1, \"USDA should be called once\")\n    }\n\n    /// Test: Korean query with no KFDA results falls back to USDA\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ud55c\uae00 \uac80\uc0c9\uc5b4\uc5d0 \uc2dd\uc57d\ucc98 \uacb0\uacfc\uac00 \uc5c6\uc73c\uba74 USDA \uacb0\uacfc \ubc18\ud658\n    func testSearchFoods_KoreanQuery_NoKFDAResults_ReturnsUSDAResults() async throws {\n        // Given: Korean query with no KFDA results\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: [])\n\n        let usdaFoods = createSampleUSDAFoods(count: 5)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\ud55c\uc2dd\", limit: 20)\n\n        // Then: Should return USDA results\n        XCTAssertEqual(results.count, 5, \"Should return 5 USDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called once\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 1, \"USDA should be called once\")\n    }\n\n    /// Test: Korean query prioritizes KFDA results first in merged list\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ud55c\uae00 \uac80\uc0c9\uc5b4\ub294 \uc2dd\uc57d\ucc98 \uacb0\uacfc\ub97c \uba3c\uc800 \ubc30\uce58\n    func testSearchFoods_KoreanQuery_KFDAResultsAppearFirst() async throws {\n        // Given: Korean query with both KFDA and USDA results\n        let kfdaFoods = createSampleKFDAFoods(count: 2)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = createSampleUSDAFoods(count: 3)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 20)\n\n        // Then: KFDA results should appear first\n        XCTAssertEqual(results.count, 5, \"Should return 5 total foods\")\n        XCTAssertEqual(results[0].source, .governmentAPI, \"First result should be KFDA\")\n        XCTAssertEqual(results[1].source, .governmentAPI, \"Second result should be KFDA\")\n        XCTAssertEqual(results[2].source, .usda, \"Third result should be USDA\")\n        XCTAssertEqual(results[3].source, .usda, \"Fourth result should be USDA\")\n        XCTAssertEqual(results[4].source, .usda, \"Fifth result should be USDA\")\n    }\n\n    // MARK: - English Query Tests (\ubcd1\ub82c \uac80\uc0c9)\n\n    /// Test: English query searches both APIs concurrently\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc601\ubb38 \uac80\uc0c9\uc5b4\ub294 \uc591\ucabd API\ub97c \ubcd1\ub82c\ub85c \uac80\uc0c9\n    func testSearchFoods_EnglishQuery_SearchesBothAPIsConcurrently() async throws {\n        // Given: English query with results from both APIs\n        let kfdaFoods = createSampleKFDAFoods(count: 5)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = createSampleUSDAFoods(count: 8)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with English query\n        let results = try await service.searchFoods(query: \"chicken\", limit: 20)\n\n        // Then: Should return combined results\n        XCTAssertEqual(results.count, 13, \"Should return 5 KFDA + 8 USDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called once\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 1, \"USDA should be called once\")\n    }\n\n    /// Test: English query prioritizes USDA results first\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc601\ubb38 \uac80\uc0c9\uc5b4\ub294 USDA \uacb0\uacfc\ub97c \uba3c\uc800 \ubc30\uce58\n    func testSearchFoods_EnglishQuery_USDAResultsAppearFirst() async throws {\n        // Given: English query with results from both APIs\n        let kfdaFoods = createSampleKFDAFoods(count: 3)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = createSampleUSDAFoods(count: 2)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with English query\n        let results = try await service.searchFoods(query: \"apple\", limit: 20)\n\n        // Then: USDA results should appear first\n        XCTAssertEqual(results.count, 5, \"Should return 5 total foods\")\n        XCTAssertEqual(results[0].source, .usda, \"First result should be USDA\")\n        XCTAssertEqual(results[1].source, .usda, \"Second result should be USDA\")\n        XCTAssertEqual(results[2].source, .governmentAPI, \"Third result should be KFDA\")\n        XCTAssertEqual(results[3].source, .governmentAPI, \"Fourth result should be KFDA\")\n        XCTAssertEqual(results[4].source, .governmentAPI, \"Fifth result should be KFDA\")\n    }\n\n    /// Test: English query with only USDA results\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc601\ubb38 \uac80\uc0c9\uc5b4\uc5d0 USDA \uacb0\uacfc\ub9cc \uc788\ub294 \uacbd\uc6b0\n    func testSearchFoods_EnglishQuery_OnlyUSDAResults() async throws {\n        // Given: English query with only USDA results\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: [])\n\n        let usdaFoods = createSampleUSDAFoods(count: 10)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with English query\n        let results = try await service.searchFoods(query: \"steak\", limit: 20)\n\n        // Then: Should return USDA results only\n        XCTAssertEqual(results.count, 10, \"Should return 10 USDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should still be called\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 1, \"USDA should be called\")\n    }\n\n    // MARK: - Deduplication Tests\n\n    /// Test: Deduplication by apiCode removes duplicates\n    ///\n    /// \ud14c\uc2a4\ud2b8: apiCode \uae30\uc900\uc73c\ub85c \uc911\ubcf5 \uc81c\uac70\n    func testSearchFoods_Deduplication_RemovesDuplicatesByApiCode() async throws {\n        // Given: Both APIs return foods with same apiCode\n        let kfdaFoods = [\n            createKFDAFood(apiCode: \"FOOD001\", name: \"\uae40\uce58\"),\n            createKFDAFood(apiCode: \"FOOD002\", name: \"\ub41c\uc7a5\"),\n        ]\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = [\n            createUSDAFood(fdcId: 12345, name: \"Kimchi\", apiCode: \"FOOD001\"), // Duplicate\n            createUSDAFood(fdcId: 67890, name: \"Rice\", apiCode: \"FOOD003\"),\n        ]\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 20)\n\n        // Then: Should remove duplicate (keep first occurrence)\n        XCTAssertEqual(results.count, 3, \"Should return 3 unique foods (4 - 1 duplicate)\")\n\n        // Verify that first occurrence is kept (KFDA version)\n        let kimchiFood = results.first { $0.apiCode == \"FOOD001\" }\n        XCTAssertNotNil(kimchiFood, \"Kimchi should be in results\")\n        XCTAssertEqual(kimchiFood?.source, .governmentAPI, \"Should keep KFDA version (first occurrence)\")\n    }\n\n    /// Test: Deduplication by name when apiCode is missing\n    ///\n    /// \ud14c\uc2a4\ud2b8: apiCode\uac00 \uc5c6\uc73c\uba74 name\uc73c\ub85c \uc911\ubcf5 \uc81c\uac70\n    func testSearchFoods_Deduplication_RemovesDuplicatesByName() async throws {\n        // Given: Foods with same name but no apiCode\n        let kfdaFoods = [\n            createKFDAFood(apiCode: nil, name: \"\uae40\uce58\ucc0c\uac1c\"),\n        ]\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = [\n            createUSDAFood(fdcId: 12345, name: \"\uae40\uce58\ucc0c\uac1c\", apiCode: nil), // Duplicate by name\n            createUSDAFood(fdcId: 67890, name: \"Rice\", apiCode: nil),\n        ]\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 20)\n\n        // Then: Should remove duplicate by name\n        XCTAssertEqual(results.count, 2, \"Should return 2 unique foods (3 - 1 duplicate)\")\n    }\n\n    // MARK: - Error Handling and Fallback Tests\n\n    /// Test: KFDA failure falls back to USDA for Korean query\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc2dd\uc57d\ucc98 API \uc2e4\ud328 \uc2dc USDA\ub85c \ud3f4\ubc31 (\ud55c\uae00 \uac80\uc0c9\uc5b4)\n    func testSearchFoods_KoreanQuery_KFDAFails_FallsBackToUSDA() async throws {\n        // Given: KFDA fails, USDA succeeds\n        mockKFDAService.shouldThrowError = NetworkError.timeout\n\n        let usdaFoods = createSampleUSDAFoods(count: 5)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with Korean query\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 20)\n\n        // Then: Should return USDA results (graceful degradation)\n        XCTAssertEqual(results.count, 5, \"Should return 5 USDA foods\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 1, \"USDA should be called once\")\n    }\n\n    /// Test: USDA failure returns only KFDA results for English query\n    ///\n    /// \ud14c\uc2a4\ud2b8: USDA API \uc2e4\ud328 \uc2dc KFDA \uacb0\uacfc\ub9cc \ubc18\ud658 (\uc601\ubb38 \uac80\uc0c9\uc5b4)\n    func testSearchFoods_EnglishQuery_USDAFails_ReturnsKFDAResults() async throws {\n        // Given: USDA fails, KFDA succeeds\n        mockUSDAService.shouldThrowError = NetworkError.networkUnavailable\n\n        let kfdaFoods = createSampleKFDAFoods(count: 5)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        // When: Searching with English query\n        let results = try await service.searchFoods(query: \"chicken\", limit: 20)\n\n        // Then: Should return KFDA results (graceful degradation)\n        XCTAssertEqual(results.count, 5, \"Should return 5 KFDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called once\")\n    }\n\n    /// Test: Both APIs fail returns empty array\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc591\ucabd API \ubaa8\ub450 \uc2e4\ud328\ud558\uba74 \ube48 \ubc30\uc5f4 \ubc18\ud658 (graceful degradation)\n    func testSearchFoods_BothAPIsFail_ReturnsEmptyArray() async throws {\n        // Given: Both APIs fail\n        mockKFDAService.shouldThrowError = NetworkError.timeout\n        mockUSDAService.shouldThrowError = NetworkError.networkUnavailable\n\n        // When: Searching with any query\n        let results = try await service.searchFoods(query: \"test\", limit: 20)\n\n        // Then: Should return empty array (no exception thrown)\n        XCTAssertEqual(results.count, 0, \"Should return empty array\")\n        XCTAssertNoThrow(results, \"Should not throw error (graceful degradation)\")\n    }\n\n    // MARK: - Limit and Boundary Tests\n\n    /// Test: Results respect limit parameter\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uacb0\uacfc\uac00 limit \ud30c\ub77c\ubbf8\ud130\ub97c \uc900\uc218\ud568\n    func testSearchFoods_RespectsLimitParameter() async throws {\n        // Given: More results than limit\n        let kfdaFoods = createSampleKFDAFoods(count: 30)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        // When: Searching with limit of 10\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 10)\n\n        // Then: Should return exactly 10 results\n        XCTAssertEqual(results.count, 10, \"Should return exactly 10 foods\")\n    }\n\n    /// Test: Empty query throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ube48 \uac80\uc0c9\uc5b4\ub294 \uc5d0\ub7ec \ubc1c\uc0dd\n    func testSearchFoods_EmptyQuery_ThrowsError() async {\n        // Given: Empty query\n        let emptyQuery = \"\"\n\n        // When/Then: Should throw invalidQuery error\n        do {\n            _ = try await service.searchFoods(query: emptyQuery, limit: 20)\n            XCTFail(\"Should throw error for empty query\")\n        } catch let error as FoodSearchError {\n            if case .invalidQuery = error {\n                // Expected error\n                XCTAssertTrue(true, \"Should throw invalidQuery error\")\n            } else {\n                XCTFail(\"Should throw invalidQuery error, got \\(error)\")\n            }\n        } catch {\n            XCTFail(\"Should throw FoodSearchError, got \\(error)\")\n        }\n    }\n\n    /// Test: Whitespace-only query throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uacf5\ubc31\ub9cc \uc788\ub294 \uac80\uc0c9\uc5b4\ub294 \uc5d0\ub7ec \ubc1c\uc0dd\n    func testSearchFoods_WhitespaceQuery_ThrowsError() async {\n        // Given: Whitespace-only query\n        let whitespaceQuery = \"   \"\n\n        // When/Then: Should throw invalidQuery error\n        do {\n            _ = try await service.searchFoods(query: whitespaceQuery, limit: 20)\n            XCTFail(\"Should throw error for whitespace query\")\n        } catch let error as FoodSearchError {\n            if case .invalidQuery = error {\n                // Expected error\n                XCTAssertTrue(true, \"Should throw invalidQuery error\")\n            } else {\n                XCTFail(\"Should throw invalidQuery error, got \\(error)\")\n            }\n        } catch {\n            XCTFail(\"Should throw FoodSearchError, got \\(error)\")\n        }\n    }\n\n    /// Test: Zero limit returns empty results\n    ///\n    /// \ud14c\uc2a4\ud2b8: limit\uc774 0\uc774\uba74 \ube48 \uacb0\uacfc \ubc18\ud658\n    func testSearchFoods_ZeroLimit_ReturnsEmpty() async throws {\n        // Given: Valid results but limit of 0\n        let kfdaFoods = createSampleKFDAFoods(count: 10)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        // When: Searching with limit of 0\n        let results = try await service.searchFoods(query: \"\uae40\uce58\", limit: 0)\n\n        // Then: Should return empty array\n        XCTAssertEqual(results.count, 0, \"Should return empty array\")\n    }\n\n    // MARK: - Korean Character Detection Tests\n\n    /// Test: Mixed Korean-English query is treated as Korean\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ud55c\uae00+\uc601\ubb38 \ud63c\ud569 \uac80\uc0c9\uc5b4\ub294 \ud55c\uae00\ub85c \ucde8\uae09\n    func testSearchFoods_MixedKoreanEnglish_TreatedAsKorean() async throws {\n        // Given: Mixed Korean-English query\n        let kfdaFoods = createSampleKFDAFoods(count: 10)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        // When: Searching with mixed query\n        let results = try await service.searchFoods(query: \"\uae40\uce58 kimchi\", limit: 20)\n\n        // Then: Should search KFDA first (Korean strategy)\n        XCTAssertEqual(results.count, 10, \"Should return 10 KFDA foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called\")\n        // USDA should not be called because KFDA returned sufficient results (\u22655)\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 0, \"USDA should not be called\")\n    }\n\n    /// Test: Pure English query uses parallel search\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc21c\uc218 \uc601\ubb38 \uac80\uc0c9\uc5b4\ub294 \ubcd1\ub82c \uac80\uc0c9\n    func testSearchFoods_PureEnglish_UsesParallelSearch() async throws {\n        // Given: Pure English query\n        let kfdaFoods = createSampleKFDAFoods(count: 5)\n        mockKFDAService.mockSearchResponse = createKFDAResponse(foods: kfdaFoods)\n\n        let usdaFoods = createSampleUSDAFoods(count: 5)\n        mockUSDAService.mockSearchResponse = createUSDAResponse(foods: usdaFoods)\n\n        // When: Searching with English query\n        let results = try await service.searchFoods(query: \"apple juice\", limit: 20)\n\n        // Then: Should call both APIs\n        XCTAssertEqual(results.count, 10, \"Should return 10 total foods\")\n        XCTAssertEqual(mockKFDAService.searchFoodsCallCount, 1, \"KFDA should be called\")\n        XCTAssertEqual(mockUSDAService.searchFoodsCallCount, 1, \"USDA should be called\")\n    }\n\n    // MARK: - Helper Methods\n\n    /// Create sample KFDA foods\n    private func createSampleKFDAFoods(count: Int) -> [KFDAFoodDTO] {\n        return (1...count).map { index in\n            KFDAFoodDTO(\n                foodCd: \"KFDA\\(String(format: \"%03d\", index))\",\n                descKor: \"\ud55c\uad6d\uc74c\uc2dd\\(index)\",\n                groupCode: \"01\",\n                groupName: \"\uace1\ub958\",\n                enercKcal: \"300\",\n                prot: \"10.0\",\n                fat: \"5.0\",\n                chocdf: \"50.0\",\n                na: \"100\",\n                fibtg: \"2.0\",\n                sugar: \"1.0\",\n                servingSize: \"210\",\n                servingWt: \"200\",\n                servingUnit: \"1\uc778\ubd84\"\n            )\n        }\n    }\n\n    /// Create sample USDA foods\n    private func createSampleUSDAFoods(count: Int) -> [USDAFoodDTO] {\n        return (1...count).map { index in\n            USDAFoodDTO(\n                fdcId: 100000 + index,\n                description: \"International Food \\(index)\",\n                dataType: \"Foundation\",\n                foodCode: \"USDA\\(String(format: \"%03d\", index))\",\n                foodNutrients: [\n                    USDANutrientDTO(nutrientId: 1008, nutrientName: \"Energy\", value: 250.0, unitName: \"kcal\"),\n                    USDANutrientDTO(nutrientId: 1003, nutrientName: \"Protein\", value: 8.0, unitName: \"g\"),\n                    USDANutrientDTO(nutrientId: 1004, nutrientName: \"Fat\", value: 4.0, unitName: \"g\"),\n                    USDANutrientDTO(nutrientId: 1005, nutrientName: \"Carbohydrate\", value: 40.0, unitName: \"g\"),\n                ],\n                servingSize: 100.0,\n                servingSizeUnit: \"g\",\n                householdServingFullText: \"1 serving\",\n                brandOwner: nil,\n                brandName: nil,\n                gtinUpc: nil,\n                ingredients: nil,\n                foodCategoryId: nil,\n                foodCategory: nil\n            )\n        }\n    }\n\n    /// Create KFDA search response\n    private func createKFDAResponse(foods: [KFDAFoodDTO]) -> KFDASearchResponseDTO {\n        return KFDASearchResponseDTO(\n            header: KFDASearchResponseDTO.Header(\n                resultCode: \"00\",\n                resultMsg: \"SUCCESS\"\n            ),\n            body: KFDASearchResponseDTO.Body(\n                totalCount: String(foods.count),\n                pageNo: \"1\",\n                numOfRows: String(foods.count),\n                items: foods.isEmpty ? [] : foods\n            )\n        )\n    }\n\n    /// Create USDA search response\n    private func createUSDAResponse(foods: [USDAFoodDTO]) -> USDASearchResponseDTO {\n        return USDASearchResponseDTO(\n            totalHits: foods.count,\n            currentPage: 1,\n            totalPages: 1,\n            pageList: nil,\n            foodSearchCriteria: nil,\n            foods: foods.isEmpty ? nil : foods\n        )\n    }\n\n    /// Create single KFDA food with custom properties\n    private func createKFDAFood(apiCode: String?, name: String) -> KFDAFoodDTO {\n        return KFDAFoodDTO(\n            foodCd: apiCode ?? \"DEFAULT\",\n            descKor: name,\n            groupCode: \"01\",\n            groupName: \"\uace1\ub958\",\n            enercKcal: \"300\",\n            prot: \"10.0\",\n            fat: \"5.0\",\n            chocdf: \"50.0\",\n            na: \"100\",\n            fibtg: \"2.0\",\n            sugar: \"1.0\",\n            servingSize: \"210\",\n            servingWt: \"200\",\n            servingUnit: \"1\uc778\ubd84\"\n        )\n    }\n\n    /// Create single USDA food with custom properties\n    private func createUSDAFood(fdcId: Int, name: String, apiCode: String?) -> USDAFoodDTO {\n        return USDAFoodDTO(\n            fdcId: fdcId,\n            description: name,\n            dataType: \"Foundation\",\n            foodCode: apiCode,\n            foodNutrients: [\n                USDANutrientDTO(nutrientId: 1008, nutrientName: \"Energy\", value: 250.0, unitName: \"kcal\"),\n                USDANutrientDTO(nutrientId: 1003, nutrientName: \"Protein\", value: 8.0, unitName: \"g\"),\n                USDANutrientDTO(nutrientId: 1004, nutrientName: \"Fat\", value: 4.0, unitName: \"g\"),\n                USDANutrientDTO(nutrientId: 1005, nutrientName: \"Carbohydrate\", value: 40.0, unitName: \"g\"),\n            ],\n            servingSize: 100.0,\n            servingSizeUnit: \"g\",\n            householdServingFullText: \"1 serving\",\n            brandOwner: nil,\n            brandName: nil,\n            gtinUpc: nil,\n            ingredients: nil,\n            foodCategoryId: nil,\n            foodCategory: nil\n        )\n    }\n}\n",
        "last_modified": "2026-01-14T22:55:39.271033"
      },
      "task_intent": {
        "title": "005-korean-food-database-integration",
        "description": "Integrate Korean Food & Drug Administration (\uc2dd\uc57d\ucc98) food nutrition database API as primary source, with USDA FoodData Central as fallback for international foods. Prioritize Korean dishes (kimchi jjigae, bibimbap, tteokbokki) that are poorly covered by competitors.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T07:43:31.559547",
  "last_updated": "2026-01-13T07:46:23.933284"
}