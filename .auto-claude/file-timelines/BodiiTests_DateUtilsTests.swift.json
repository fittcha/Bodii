{
  "file_path": "BodiiTests/DateUtilsTests.swift",
  "main_branch_history": [],
  "task_views": {
    "004-project-foundation-core-data-model": {
      "task_id": "004-project-foundation-core-data-model",
      "branch_point": {
        "commit_hash": "2abdae73fb6199bcbf4f21f6deeb7952225f81e6",
        "content": "",
        "timestamp": "2026-01-12T19:14:54.682468"
      },
      "worktree_state": {
        "content": "//\n//  DateUtilsTests.swift\n//  BodiiTests\n//\n//  Created by Auto-Claude on 2026-01-12.\n//\n\nimport XCTest\n@testable import Bodii\n\n/// Unit tests for DateUtils focusing on 02:00 sleep boundary logic\n///\n/// DateUtils\uc758 02:00 \uc218\uba74 \uacbd\uacc4 \ub85c\uc9c1\uc5d0 \ub300\ud55c \ub2e8\uc704 \ud14c\uc2a4\ud2b8\nfinal class DateUtilsTests: XCTestCase {\n\n    // MARK: - Test Helpers\n\n    /// Creates a date with specific year, month, day, hour, and minute components\n    private func makeDate(year: Int, month: Int, day: Int, hour: Int, minute: Int = 0) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n        components.hour = hour\n        components.minute = minute\n        components.second = 0\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    /// Creates an expected date (start of day)\n    private func makeExpectedDate(year: Int, month: Int, day: Int) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create expected date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    // MARK: - Sleep Boundary Tests (getLogicalDate)\n\n    /// Test: 01:59 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:59\ub294 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0159_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:59 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:00\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0200_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:00 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:01 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:01\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0201_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:01 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:01 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Midnight (00:00) should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc790\uc815(00:00)\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Midnight_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight (00:00) should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 00:01 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 00:01\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0001_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:01\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"00:01 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 01:00 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:00\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0100_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:00 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 03:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 03:00\uc740 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0300_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 03:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"03:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Noon (12:00) should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc815\uc624(12:00)\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Noon_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 12:00 (noon)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Noon (12:00) should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 23:59 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 23:59\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_2359_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 23:59\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"23:59 should return current day for sleep tracking\"\n        )\n    }\n\n    // MARK: - Month/Year Boundary Tests\n\n    /// Test: Midnight on first day of month should return previous month's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc6d4 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\uc6d4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfMonth_Midnight_ReturnsPreviousMonthLastDay() {\n        // Given: February 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 2, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 31, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of month should return previous month's last day\"\n        )\n    }\n\n    /// Test: Midnight on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_Midnight_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 01:59 on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 01:59\ub294 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0159_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 01:59\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 02:00 on first day of year should return current day (Jan 1)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 02:00\uc740 \ub2f9\uc77c(1\uc6d4 1\uc77c)\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0200_ReturnsCurrentDay() {\n        // Given: January 1, 2026 at 02:00\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 1, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 1)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 on first day of year should return current day (Jan 1)\"\n        )\n    }\n\n    // MARK: - getSleepDate Tests (Alias Function)\n\n    /// Test: getSleepDate should behave identically to getLogicalDate\n    ///\n    /// \ud14c\uc2a4\ud2b8: getSleepDate\ub294 getLogicalDate\uc640 \ub3d9\uc77c\ud558\uac8c \ub3d9\uc791\ud574\uc57c \ud568\n    func testGetSleepDate_BehavesIdenticallyToGetLogicalDate() {\n        // Given: Various test dates\n        let testDates = [\n            makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1),\n            makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n        ]\n\n        // When/Then: getSleepDate should return same result as getLogicalDate\n        for testDate in testDates {\n            let sleepDate = DateUtils.getSleepDate(for: testDate)\n            let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n            XCTAssertEqual(\n                sleepDate.yyyyMMdd,\n                logicalDate.yyyyMMdd,\n                \"getSleepDate should return same date as getLogicalDate for \\(testDate.yyyyMMddHHmmss)\"\n            )\n        }\n    }\n\n    // MARK: - Edge Cases from Documentation\n\n    /// Test: Edge case scenario from docs - 3 AM on Jan 12 should return Jan 11 for sleep popup\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ubb38\uc11c\uc758 \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - 1\uc6d4 12\uc77c \uc624\uc804 3\uc2dc\ub294 \uc218\uba74 \ud31d\uc5c5\uc744 \uc704\ud574 1\uc6d4 11\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_DocScenario_3AMReturnsYesterday() {\n        // Given: January 12, 2026 at 03:00 (documented scenario)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting sleep date (logical date for yesterday's sleep)\n        let sleepDate = DateUtils.getSleepDate(for: testDate)\n\n        // Then: At 03:00, we're recording yesterday's (Jan 11) sleep\n        // But the logical date for 03:00 itself is Jan 12\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            sleepDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"At 03:00 AM, the logical date is current day (for entering yesterday's sleep data)\"\n        )\n    }\n\n    /// Test: Edge case - sequential times across boundary\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - \uacbd\uacc4\ub97c \ub118\ub294 \uc5f0\uc18d\ub41c \uc2dc\uac04\n    func testGetLogicalDate_SequentialTimesAcrossBoundary() {\n        let year = 2026, month = 1, day = 12\n\n        // 01:58 -> previous day\n        let date0158 = makeDate(year: year, month: month, day: day, hour: 1, minute: 58)\n        let logical0158 = DateUtils.getLogicalDate(for: date0158)\n        XCTAssertEqual(logical0158.day, 11, \"01:58 should return previous day\")\n\n        // 01:59 -> previous day\n        let date0159 = makeDate(year: year, month: month, day: day, hour: 1, minute: 59)\n        let logical0159 = DateUtils.getLogicalDate(for: date0159)\n        XCTAssertEqual(logical0159.day, 11, \"01:59 should return previous day\")\n\n        // 02:00 -> current day (boundary)\n        let date0200 = makeDate(year: year, month: month, day: day, hour: 2, minute: 0)\n        let logical0200 = DateUtils.getLogicalDate(for: date0200)\n        XCTAssertEqual(logical0200.day, 12, \"02:00 should return current day\")\n\n        // 02:01 -> current day\n        let date0201 = makeDate(year: year, month: month, day: day, hour: 2, minute: 1)\n        let logical0201 = DateUtils.getLogicalDate(for: date0201)\n        XCTAssertEqual(logical0201.day, 12, \"02:01 should return current day\")\n\n        // 02:02 -> current day\n        let date0202 = makeDate(year: year, month: month, day: day, hour: 2, minute: 2)\n        let logical0202 = DateUtils.getLogicalDate(for: date0202)\n        XCTAssertEqual(logical0202.day, 12, \"02:02 should return current day\")\n    }\n\n    // MARK: - Date Formatting Utilities Tests\n\n    /// Test: formatKorean returns correct Korean format\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatKorean\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \ud615\uc2dd\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatKorean_ReturnsCorrectFormat() {\n        // Given: A specific date\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 15, minute: 30)\n\n        // When: Formatting in Korean\n        let formatted = DateUtils.formatKorean(testDate)\n\n        // Then: Should contain Korean date components\n        XCTAssertTrue(\n            formatted.contains(\"2026\") && formatted.contains(\"1\") && formatted.contains(\"12\"),\n            \"Korean formatted date should contain year, month, and day\"\n        )\n        XCTAssertTrue(\n            formatted.contains(\"\ub144\") || formatted.contains(\"\uc6d4\") || formatted.contains(\"\uc77c\"),\n            \"Korean formatted date should contain Korean characters\"\n        )\n    }\n\n    /// Test: formatDuration returns correct Korean duration strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatDuration\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc2dc\uac04 \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatDuration_ReturnsCorrectStrings() {\n        // Test hours and minutes\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 450), \"7\uc2dc\uac04 30\ubd84\")\n\n        // Test hours only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 60), \"1\uc2dc\uac04\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 120), \"2\uc2dc\uac04\")\n\n        // Test minutes only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 45), \"45\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 0), \"0\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1), \"1\ubd84\")\n    }\n\n    /// Test: daysBetween calculates correct day differences\n    ///\n    /// \ud14c\uc2a4\ud2b8: daysBetween\uc774 \uc62c\ubc14\ub978 \uc77c\uc218 \ucc28\uc774\ub97c \uacc4\uc0b0\ud558\ub294\uc9c0 \ud655\uc778\n    func testDaysBetween_CalculatesCorrectDifferences() {\n        // Given: Two dates\n        let date1 = makeDate(year: 2026, month: 1, day: 12, hour: 10, minute: 0)\n        let date2 = makeDate(year: 2026, month: 1, day: 19, hour: 15, minute: 30)\n\n        // When: Calculating days between\n        let days = DateUtils.daysBetween(from: date1, to: date2)\n\n        // Then: Should return 7 days\n        XCTAssertEqual(days, 7, \"Should calculate 7 days between Jan 12 and Jan 19\")\n    }\n\n    /// Test: relativeDate returns correct Korean relative strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: relativeDate\uac00 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc0c1\ub300 \ub0a0\uc9dc \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testRelativeDate_ReturnsCorrectStrings() {\n        // Given: Today's date\n        let today = Date()\n\n        // When/Then: Testing relative dates\n        let todayStr = DateUtils.relativeDate(today)\n        XCTAssertEqual(todayStr, \"\uc624\ub298\", \"Today should return '\uc624\ub298'\")\n\n        let yesterday = today.adding(days: -1)\n        let yesterdayStr = DateUtils.relativeDate(yesterday)\n        XCTAssertEqual(yesterdayStr, \"\uc5b4\uc81c\", \"Yesterday should return '\uc5b4\uc81c'\")\n\n        let tomorrow = today.adding(days: 1)\n        let tomorrowStr = DateUtils.relativeDate(tomorrow)\n        XCTAssertEqual(tomorrowStr, \"\ub0b4\uc77c\", \"Tomorrow should return '\ub0b4\uc77c'\")\n\n        // For dates beyond yesterday/tomorrow, should return formatted date\n        let lastWeek = today.adding(days: -7)\n        let lastWeekStr = DateUtils.relativeDate(lastWeek)\n        XCTAssertNotEqual(lastWeekStr, \"\uc624\ub298\", \"Last week should not return '\uc624\ub298'\")\n        XCTAssertNotEqual(lastWeekStr, \"\uc5b4\uc81c\", \"Last week should not return '\uc5b4\uc81c'\")\n    }\n}\n",
        "last_modified": "2026-01-12T19:28:09.046585"
      },
      "task_intent": {
        "title": "004-project-foundation-core-data-model",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-12T19:14:55.184291",
  "last_updated": "2026-01-12T19:14:55.194072"
}