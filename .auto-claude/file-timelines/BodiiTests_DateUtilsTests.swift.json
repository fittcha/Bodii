{
  "file_path": "BodiiTests/DateUtilsTests.swift",
  "main_branch_history": [],
  "task_views": {
    "004-project-foundation-core-data-model": {
      "task_id": "004-project-foundation-core-data-model",
      "branch_point": {
        "commit_hash": "2abdae73fb6199bcbf4f21f6deeb7952225f81e6",
        "content": "",
        "timestamp": "2026-01-12T19:14:54.682468"
      },
      "worktree_state": {
        "content": "//\n//  DateUtilsTests.swift\n//  BodiiTests\n//\n//  Created by Auto-Claude on 2026-01-12.\n//\n\nimport XCTest\n@testable import Bodii\n\n/// Unit tests for DateUtils focusing on 02:00 sleep boundary logic\n///\n/// DateUtils\uc758 02:00 \uc218\uba74 \uacbd\uacc4 \ub85c\uc9c1\uc5d0 \ub300\ud55c \ub2e8\uc704 \ud14c\uc2a4\ud2b8\nfinal class DateUtilsTests: XCTestCase {\n\n    // MARK: - Test Helpers\n\n    /// Creates a date with specific year, month, day, hour, and minute components\n    private func makeDate(year: Int, month: Int, day: Int, hour: Int, minute: Int = 0) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n        components.hour = hour\n        components.minute = minute\n        components.second = 0\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    /// Creates an expected date (start of day)\n    private func makeExpectedDate(year: Int, month: Int, day: Int) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create expected date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    // MARK: - Sleep Boundary Tests (getLogicalDate)\n\n    /// Test: 01:59 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:59\ub294 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0159_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:59 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:00\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0200_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:00 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:01 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:01\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0201_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:01 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:01 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Midnight (00:00) should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc790\uc815(00:00)\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Midnight_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight (00:00) should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 00:01 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 00:01\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0001_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:01\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"00:01 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 01:00 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:00\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0100_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:00 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 03:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 03:00\uc740 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0300_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 03:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"03:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Noon (12:00) should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc815\uc624(12:00)\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Noon_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 12:00 (noon)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Noon (12:00) should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 23:59 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 23:59\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_2359_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 23:59\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"23:59 should return current day for sleep tracking\"\n        )\n    }\n\n    // MARK: - Month/Year Boundary Tests\n\n    /// Test: Midnight on first day of month should return previous month's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc6d4 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\uc6d4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfMonth_Midnight_ReturnsPreviousMonthLastDay() {\n        // Given: February 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 2, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 31, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of month should return previous month's last day\"\n        )\n    }\n\n    /// Test: Midnight on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_Midnight_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 01:59 on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 01:59\ub294 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0159_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 01:59\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 02:00 on first day of year should return current day (Jan 1)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 02:00\uc740 \ub2f9\uc77c(1\uc6d4 1\uc77c)\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0200_ReturnsCurrentDay() {\n        // Given: January 1, 2026 at 02:00\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 1, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 1)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 on first day of year should return current day (Jan 1)\"\n        )\n    }\n\n    // MARK: - getSleepDate Tests (Alias Function)\n\n    /// Test: getSleepDate should behave identically to getLogicalDate\n    ///\n    /// \ud14c\uc2a4\ud2b8: getSleepDate\ub294 getLogicalDate\uc640 \ub3d9\uc77c\ud558\uac8c \ub3d9\uc791\ud574\uc57c \ud568\n    func testGetSleepDate_BehavesIdenticallyToGetLogicalDate() {\n        // Given: Various test dates\n        let testDates = [\n            makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1),\n            makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n        ]\n\n        // When/Then: getSleepDate should return same result as getLogicalDate\n        for testDate in testDates {\n            let sleepDate = DateUtils.getSleepDate(for: testDate)\n            let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n            XCTAssertEqual(\n                sleepDate.yyyyMMdd,\n                logicalDate.yyyyMMdd,\n                \"getSleepDate should return same date as getLogicalDate for \\(testDate.yyyyMMddHHmmss)\"\n            )\n        }\n    }\n\n    // MARK: - Edge Cases from Documentation\n\n    /// Test: Edge case scenario from docs - 3 AM on Jan 12 should return Jan 11 for sleep popup\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ubb38\uc11c\uc758 \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - 1\uc6d4 12\uc77c \uc624\uc804 3\uc2dc\ub294 \uc218\uba74 \ud31d\uc5c5\uc744 \uc704\ud574 1\uc6d4 11\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_DocScenario_3AMReturnsYesterday() {\n        // Given: January 12, 2026 at 03:00 (documented scenario)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting sleep date (logical date for yesterday's sleep)\n        let sleepDate = DateUtils.getSleepDate(for: testDate)\n\n        // Then: At 03:00, we're recording yesterday's (Jan 11) sleep\n        // But the logical date for 03:00 itself is Jan 12\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            sleepDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"At 03:00 AM, the logical date is current day (for entering yesterday's sleep data)\"\n        )\n    }\n\n    /// Test: Edge case - sequential times across boundary\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - \uacbd\uacc4\ub97c \ub118\ub294 \uc5f0\uc18d\ub41c \uc2dc\uac04\n    func testGetLogicalDate_SequentialTimesAcrossBoundary() {\n        let year = 2026, month = 1, day = 12\n\n        // 01:58 -> previous day\n        let date0158 = makeDate(year: year, month: month, day: day, hour: 1, minute: 58)\n        let logical0158 = DateUtils.getLogicalDate(for: date0158)\n        XCTAssertEqual(logical0158.day, 11, \"01:58 should return previous day\")\n\n        // 01:59 -> previous day\n        let date0159 = makeDate(year: year, month: month, day: day, hour: 1, minute: 59)\n        let logical0159 = DateUtils.getLogicalDate(for: date0159)\n        XCTAssertEqual(logical0159.day, 11, \"01:59 should return previous day\")\n\n        // 02:00 -> current day (boundary)\n        let date0200 = makeDate(year: year, month: month, day: day, hour: 2, minute: 0)\n        let logical0200 = DateUtils.getLogicalDate(for: date0200)\n        XCTAssertEqual(logical0200.day, 12, \"02:00 should return current day\")\n\n        // 02:01 -> current day\n        let date0201 = makeDate(year: year, month: month, day: day, hour: 2, minute: 1)\n        let logical0201 = DateUtils.getLogicalDate(for: date0201)\n        XCTAssertEqual(logical0201.day, 12, \"02:01 should return current day\")\n\n        // 02:02 -> current day\n        let date0202 = makeDate(year: year, month: month, day: day, hour: 2, minute: 2)\n        let logical0202 = DateUtils.getLogicalDate(for: date0202)\n        XCTAssertEqual(logical0202.day, 12, \"02:02 should return current day\")\n    }\n\n    // MARK: - Date Formatting Utilities Tests\n\n    /// Test: formatKorean returns correct Korean format\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatKorean\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \ud615\uc2dd\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatKorean_ReturnsCorrectFormat() {\n        // Given: A specific date\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 15, minute: 30)\n\n        // When: Formatting in Korean\n        let formatted = DateUtils.formatKorean(testDate)\n\n        // Then: Should contain Korean date components\n        XCTAssertTrue(\n            formatted.contains(\"2026\") && formatted.contains(\"1\") && formatted.contains(\"12\"),\n            \"Korean formatted date should contain year, month, and day\"\n        )\n        XCTAssertTrue(\n            formatted.contains(\"\ub144\") || formatted.contains(\"\uc6d4\") || formatted.contains(\"\uc77c\"),\n            \"Korean formatted date should contain Korean characters\"\n        )\n    }\n\n    /// Test: formatDuration returns correct Korean duration strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatDuration\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc2dc\uac04 \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatDuration_ReturnsCorrectStrings() {\n        // Test hours and minutes\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 450), \"7\uc2dc\uac04 30\ubd84\")\n\n        // Test hours only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 60), \"1\uc2dc\uac04\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 120), \"2\uc2dc\uac04\")\n\n        // Test minutes only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 45), \"45\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 0), \"0\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1), \"1\ubd84\")\n    }\n\n    /// Test: daysBetween calculates correct day differences\n    ///\n    /// \ud14c\uc2a4\ud2b8: daysBetween\uc774 \uc62c\ubc14\ub978 \uc77c\uc218 \ucc28\uc774\ub97c \uacc4\uc0b0\ud558\ub294\uc9c0 \ud655\uc778\n    func testDaysBetween_CalculatesCorrectDifferences() {\n        // Given: Two dates\n        let date1 = makeDate(year: 2026, month: 1, day: 12, hour: 10, minute: 0)\n        let date2 = makeDate(year: 2026, month: 1, day: 19, hour: 15, minute: 30)\n\n        // When: Calculating days between\n        let days = DateUtils.daysBetween(from: date1, to: date2)\n\n        // Then: Should return 7 days\n        XCTAssertEqual(days, 7, \"Should calculate 7 days between Jan 12 and Jan 19\")\n    }\n\n    /// Test: relativeDate returns correct Korean relative strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: relativeDate\uac00 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc0c1\ub300 \ub0a0\uc9dc \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testRelativeDate_ReturnsCorrectStrings() {\n        // Given: Today's date\n        let today = Date()\n\n        // When/Then: Testing relative dates\n        let todayStr = DateUtils.relativeDate(today)\n        XCTAssertEqual(todayStr, \"\uc624\ub298\", \"Today should return '\uc624\ub298'\")\n\n        let yesterday = today.adding(days: -1)\n        let yesterdayStr = DateUtils.relativeDate(yesterday)\n        XCTAssertEqual(yesterdayStr, \"\uc5b4\uc81c\", \"Yesterday should return '\uc5b4\uc81c'\")\n\n        let tomorrow = today.adding(days: 1)\n        let tomorrowStr = DateUtils.relativeDate(tomorrow)\n        XCTAssertEqual(tomorrowStr, \"\ub0b4\uc77c\", \"Tomorrow should return '\ub0b4\uc77c'\")\n\n        // For dates beyond yesterday/tomorrow, should return formatted date\n        let lastWeek = today.adding(days: -7)\n        let lastWeekStr = DateUtils.relativeDate(lastWeek)\n        XCTAssertNotEqual(lastWeekStr, \"\uc624\ub298\", \"Last week should not return '\uc624\ub298'\")\n        XCTAssertNotEqual(lastWeekStr, \"\uc5b4\uc81c\", \"Last week should not return '\uc5b4\uc81c'\")\n    }\n}\n",
        "last_modified": "2026-01-14T22:57:13.080279"
      },
      "task_intent": {
        "title": "004-project-foundation-core-data-model",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "009-sleep-tracking-with-5-status-system": {
      "task_id": "009-sleep-tracking-with-5-status-system",
      "branch_point": {
        "commit_hash": "4e56d606f7b0d4cb74120dd392544f3fe2d4f5b4",
        "content": "//\n//  DateUtilsTests.swift\n//  BodiiTests\n//\n//  Created by Auto-Claude on 2026-01-12.\n//\n\nimport XCTest\n@testable import Bodii\n\n/// Unit tests for DateUtils focusing on 02:00 sleep boundary logic\n///\n/// DateUtils\uc758 02:00 \uc218\uba74 \uacbd\uacc4 \ub85c\uc9c1\uc5d0 \ub300\ud55c \ub2e8\uc704 \ud14c\uc2a4\ud2b8\nfinal class DateUtilsTests: XCTestCase {\n\n    // MARK: - Test Helpers\n\n    /// Creates a date with specific year, month, day, hour, and minute components\n    private func makeDate(year: Int, month: Int, day: Int, hour: Int, minute: Int = 0) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n        components.hour = hour\n        components.minute = minute\n        components.second = 0\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    /// Creates an expected date (start of day)\n    private func makeExpectedDate(year: Int, month: Int, day: Int) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create expected date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    // MARK: - Sleep Boundary Tests (getLogicalDate)\n\n    /// Test: 01:59 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:59\ub294 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0159_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:59 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:00\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0200_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:00 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:01 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:01\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0201_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:01 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:01 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Midnight (00:00) should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc790\uc815(00:00)\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Midnight_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight (00:00) should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 00:01 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 00:01\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0001_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:01\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"00:01 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 01:00 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:00\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0100_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:00 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 03:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 03:00\uc740 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0300_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 03:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"03:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Noon (12:00) should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc815\uc624(12:00)\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Noon_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 12:00 (noon)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Noon (12:00) should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 23:59 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 23:59\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_2359_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 23:59\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"23:59 should return current day for sleep tracking\"\n        )\n    }\n\n    // MARK: - Month/Year Boundary Tests\n\n    /// Test: Midnight on first day of month should return previous month's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc6d4 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\uc6d4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfMonth_Midnight_ReturnsPreviousMonthLastDay() {\n        // Given: February 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 2, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 31, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of month should return previous month's last day\"\n        )\n    }\n\n    /// Test: Midnight on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_Midnight_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 01:59 on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 01:59\ub294 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0159_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 01:59\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 02:00 on first day of year should return current day (Jan 1)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 02:00\uc740 \ub2f9\uc77c(1\uc6d4 1\uc77c)\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0200_ReturnsCurrentDay() {\n        // Given: January 1, 2026 at 02:00\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 1, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 1)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 on first day of year should return current day (Jan 1)\"\n        )\n    }\n\n    // MARK: - getSleepDate Tests (Alias Function)\n\n    /// Test: getSleepDate should behave identically to getLogicalDate\n    ///\n    /// \ud14c\uc2a4\ud2b8: getSleepDate\ub294 getLogicalDate\uc640 \ub3d9\uc77c\ud558\uac8c \ub3d9\uc791\ud574\uc57c \ud568\n    func testGetSleepDate_BehavesIdenticallyToGetLogicalDate() {\n        // Given: Various test dates\n        let testDates = [\n            makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1),\n            makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n        ]\n\n        // When/Then: getSleepDate should return same result as getLogicalDate\n        for testDate in testDates {\n            let sleepDate = DateUtils.getSleepDate(for: testDate)\n            let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n            XCTAssertEqual(\n                sleepDate.yyyyMMdd,\n                logicalDate.yyyyMMdd,\n                \"getSleepDate should return same date as getLogicalDate for \\(testDate.yyyyMMddHHmmss)\"\n            )\n        }\n    }\n\n    // MARK: - Edge Cases from Documentation\n\n    /// Test: Edge case scenario from docs - 3 AM on Jan 12 should return Jan 11 for sleep popup\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ubb38\uc11c\uc758 \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - 1\uc6d4 12\uc77c \uc624\uc804 3\uc2dc\ub294 \uc218\uba74 \ud31d\uc5c5\uc744 \uc704\ud574 1\uc6d4 11\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_DocScenario_3AMReturnsYesterday() {\n        // Given: January 12, 2026 at 03:00 (documented scenario)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting sleep date (logical date for yesterday's sleep)\n        let sleepDate = DateUtils.getSleepDate(for: testDate)\n\n        // Then: At 03:00, we're recording yesterday's (Jan 11) sleep\n        // But the logical date for 03:00 itself is Jan 12\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            sleepDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"At 03:00 AM, the logical date is current day (for entering yesterday's sleep data)\"\n        )\n    }\n\n    /// Test: Edge case - sequential times across boundary\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - \uacbd\uacc4\ub97c \ub118\ub294 \uc5f0\uc18d\ub41c \uc2dc\uac04\n    func testGetLogicalDate_SequentialTimesAcrossBoundary() {\n        let year = 2026, month = 1, day = 12\n\n        // 01:58 -> previous day\n        let date0158 = makeDate(year: year, month: month, day: day, hour: 1, minute: 58)\n        let logical0158 = DateUtils.getLogicalDate(for: date0158)\n        XCTAssertEqual(logical0158.day, 11, \"01:58 should return previous day\")\n\n        // 01:59 -> previous day\n        let date0159 = makeDate(year: year, month: month, day: day, hour: 1, minute: 59)\n        let logical0159 = DateUtils.getLogicalDate(for: date0159)\n        XCTAssertEqual(logical0159.day, 11, \"01:59 should return previous day\")\n\n        // 02:00 -> current day (boundary)\n        let date0200 = makeDate(year: year, month: month, day: day, hour: 2, minute: 0)\n        let logical0200 = DateUtils.getLogicalDate(for: date0200)\n        XCTAssertEqual(logical0200.day, 12, \"02:00 should return current day\")\n\n        // 02:01 -> current day\n        let date0201 = makeDate(year: year, month: month, day: day, hour: 2, minute: 1)\n        let logical0201 = DateUtils.getLogicalDate(for: date0201)\n        XCTAssertEqual(logical0201.day, 12, \"02:01 should return current day\")\n\n        // 02:02 -> current day\n        let date0202 = makeDate(year: year, month: month, day: day, hour: 2, minute: 2)\n        let logical0202 = DateUtils.getLogicalDate(for: date0202)\n        XCTAssertEqual(logical0202.day, 12, \"02:02 should return current day\")\n    }\n\n    // MARK: - Date Formatting Utilities Tests\n\n    /// Test: formatKorean returns correct Korean format\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatKorean\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \ud615\uc2dd\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatKorean_ReturnsCorrectFormat() {\n        // Given: A specific date\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 15, minute: 30)\n\n        // When: Formatting in Korean\n        let formatted = DateUtils.formatKorean(testDate)\n\n        // Then: Should contain Korean date components\n        XCTAssertTrue(\n            formatted.contains(\"2026\") && formatted.contains(\"1\") && formatted.contains(\"12\"),\n            \"Korean formatted date should contain year, month, and day\"\n        )\n        XCTAssertTrue(\n            formatted.contains(\"\ub144\") || formatted.contains(\"\uc6d4\") || formatted.contains(\"\uc77c\"),\n            \"Korean formatted date should contain Korean characters\"\n        )\n    }\n\n    /// Test: formatDuration returns correct Korean duration strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatDuration\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc2dc\uac04 \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatDuration_ReturnsCorrectStrings() {\n        // Test hours and minutes\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 450), \"7\uc2dc\uac04 30\ubd84\")\n\n        // Test hours only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 60), \"1\uc2dc\uac04\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 120), \"2\uc2dc\uac04\")\n\n        // Test minutes only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 45), \"45\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 0), \"0\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1), \"1\ubd84\")\n    }\n\n    /// Test: daysBetween calculates correct day differences\n    ///\n    /// \ud14c\uc2a4\ud2b8: daysBetween\uc774 \uc62c\ubc14\ub978 \uc77c\uc218 \ucc28\uc774\ub97c \uacc4\uc0b0\ud558\ub294\uc9c0 \ud655\uc778\n    func testDaysBetween_CalculatesCorrectDifferences() {\n        // Given: Two dates\n        let date1 = makeDate(year: 2026, month: 1, day: 12, hour: 10, minute: 0)\n        let date2 = makeDate(year: 2026, month: 1, day: 19, hour: 15, minute: 30)\n\n        // When: Calculating days between\n        let days = DateUtils.daysBetween(from: date1, to: date2)\n\n        // Then: Should return 7 days\n        XCTAssertEqual(days, 7, \"Should calculate 7 days between Jan 12 and Jan 19\")\n    }\n\n    /// Test: relativeDate returns correct Korean relative strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: relativeDate\uac00 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc0c1\ub300 \ub0a0\uc9dc \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testRelativeDate_ReturnsCorrectStrings() {\n        // Given: Today's date\n        let today = Date()\n\n        // When/Then: Testing relative dates\n        let todayStr = DateUtils.relativeDate(today)\n        XCTAssertEqual(todayStr, \"\uc624\ub298\", \"Today should return '\uc624\ub298'\")\n\n        let yesterday = today.adding(days: -1)\n        let yesterdayStr = DateUtils.relativeDate(yesterday)\n        XCTAssertEqual(yesterdayStr, \"\uc5b4\uc81c\", \"Yesterday should return '\uc5b4\uc81c'\")\n\n        let tomorrow = today.adding(days: 1)\n        let tomorrowStr = DateUtils.relativeDate(tomorrow)\n        XCTAssertEqual(tomorrowStr, \"\ub0b4\uc77c\", \"Tomorrow should return '\ub0b4\uc77c'\")\n\n        // For dates beyond yesterday/tomorrow, should return formatted date\n        let lastWeek = today.adding(days: -7)\n        let lastWeekStr = DateUtils.relativeDate(lastWeek)\n        XCTAssertNotEqual(lastWeekStr, \"\uc624\ub298\", \"Last week should not return '\uc624\ub298'\")\n        XCTAssertNotEqual(lastWeekStr, \"\uc5b4\uc81c\", \"Last week should not return '\uc5b4\uc81c'\")\n    }\n}\n",
        "timestamp": "2026-01-14T21:03:40.462795"
      },
      "worktree_state": {
        "content": "//\n//  DateUtilsTests.swift\n//  BodiiTests\n//\n//  Created by Auto-Claude on 2026-01-12.\n//\n\nimport XCTest\n@testable import Bodii\n\n/// Unit tests for DateUtils focusing on 02:00 sleep boundary logic\n///\n/// DateUtils\uc758 02:00 \uc218\uba74 \uacbd\uacc4 \ub85c\uc9c1\uc5d0 \ub300\ud55c \ub2e8\uc704 \ud14c\uc2a4\ud2b8\nfinal class DateUtilsTests: XCTestCase {\n\n    // MARK: - Test Helpers\n\n    /// Creates a date with specific year, month, day, hour, and minute components\n    private func makeDate(year: Int, month: Int, day: Int, hour: Int, minute: Int = 0) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n        components.hour = hour\n        components.minute = minute\n        components.second = 0\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    /// Creates an expected date (start of day)\n    private func makeExpectedDate(year: Int, month: Int, day: Int) -> Date {\n        var components = DateComponents()\n        components.year = year\n        components.month = month\n        components.day = day\n\n        guard let date = Calendar.current.date(from: components) else {\n            XCTFail(\"Failed to create expected date from components\")\n            return Date()\n        }\n\n        return date\n    }\n\n    // MARK: - Sleep Boundary Tests (getLogicalDate)\n\n    /// Test: 01:59 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:59\ub294 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0159_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:59 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:00\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0200_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:00 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 02:01 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 02:01\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0201_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 02:01 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:01 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Midnight (00:00) should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc790\uc815(00:00)\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Midnight_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight (00:00) should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 00:01 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 00:01\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0001_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 00:01\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 1)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"00:01 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 01:00 should return previous day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 01:00\uc740 \uc804\ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0100_ReturnsPreviousDay() {\n        // Given: January 12, 2026 at 01:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 11, 2026 (previous day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:00 should return previous day for sleep tracking\"\n        )\n    }\n\n    /// Test: 03:00 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 03:00\uc740 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_0300_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 03:00\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"03:00 should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: Noon (12:00) should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc815\uc624(12:00)\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_Noon_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 12:00 (noon)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Noon (12:00) should return current day for sleep tracking\"\n        )\n    }\n\n    /// Test: 23:59 should return current day\n    ///\n    /// \ud14c\uc2a4\ud2b8: 23:59\ub294 \ub2f9\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_2359_ReturnsCurrentDay() {\n        // Given: January 12, 2026 at 23:59\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 12, 2026 (current day)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"23:59 should return current day for sleep tracking\"\n        )\n    }\n\n    // MARK: - Month/Year Boundary Tests\n\n    /// Test: Midnight on first day of month should return previous month's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc6d4 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\uc6d4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfMonth_Midnight_ReturnsPreviousMonthLastDay() {\n        // Given: February 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 2, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 31, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of month should return previous month's last day\"\n        )\n    }\n\n    /// Test: Midnight on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 \uc790\uc815\uc740 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_Midnight_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 00:00 (midnight)\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 01:59 on first day of year should return previous year's last day\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 01:59\ub294 \uc804\ub144\ub3c4 \ub9c8\uc9c0\ub9c9 \ub0a0\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0159_ReturnsPreviousYearLastDay() {\n        // Given: January 1, 2026 at 01:59\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 on first day of year should return previous year's last day\"\n        )\n    }\n\n    /// Test: 02:00 on first day of year should return current day (Jan 1)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uccab\ub0a0 02:00\uc740 \ub2f9\uc77c(1\uc6d4 1\uc77c)\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_FirstDayOfYear_0200_ReturnsCurrentDay() {\n        // Given: January 1, 2026 at 02:00\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 2, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return January 1, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 1)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"02:00 on first day of year should return current day (Jan 1)\"\n        )\n    }\n\n    // MARK: - getSleepDate Tests (Alias Function)\n\n    /// Test: getSleepDate should behave identically to getLogicalDate\n    ///\n    /// \ud14c\uc2a4\ud2b8: getSleepDate\ub294 getLogicalDate\uc640 \ub3d9\uc77c\ud558\uac8c \ub3d9\uc791\ud574\uc57c \ud568\n    func testGetSleepDate_BehavesIdenticallyToGetLogicalDate() {\n        // Given: Various test dates\n        let testDates = [\n            makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1),\n            makeDate(year: 2026, month: 1, day: 12, hour: 12, minute: 0),\n            makeDate(year: 2026, month: 1, day: 12, hour: 23, minute: 59)\n        ]\n\n        // When/Then: getSleepDate should return same result as getLogicalDate\n        for testDate in testDates {\n            let sleepDate = DateUtils.getSleepDate(for: testDate)\n            let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n            XCTAssertEqual(\n                sleepDate.yyyyMMdd,\n                logicalDate.yyyyMMdd,\n                \"getSleepDate should return same date as getLogicalDate for \\(testDate.yyyyMMddHHmmss)\"\n            )\n        }\n    }\n\n    // MARK: - Edge Cases from Documentation\n\n    /// Test: Edge case scenario from docs - 3 AM on Jan 12 should return Jan 11 for sleep popup\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ubb38\uc11c\uc758 \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - 1\uc6d4 12\uc77c \uc624\uc804 3\uc2dc\ub294 \uc218\uba74 \ud31d\uc5c5\uc744 \uc704\ud574 1\uc6d4 11\uc77c\uc744 \ubc18\ud658\ud574\uc57c \ud568\n    func testGetLogicalDate_DocScenario_3AMReturnsYesterday() {\n        // Given: January 12, 2026 at 03:00 (documented scenario)\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 0)\n\n        // When: Getting sleep date (logical date for yesterday's sleep)\n        let sleepDate = DateUtils.getSleepDate(for: testDate)\n\n        // Then: At 03:00, we're recording yesterday's (Jan 11) sleep\n        // But the logical date for 03:00 itself is Jan 12\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            sleepDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"At 03:00 AM, the logical date is current day (for entering yesterday's sleep data)\"\n        )\n    }\n\n    /// Test: Edge case - sequential times across boundary\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc5e3\uc9c0 \ucf00\uc774\uc2a4 - \uacbd\uacc4\ub97c \ub118\ub294 \uc5f0\uc18d\ub41c \uc2dc\uac04\n    func testGetLogicalDate_SequentialTimesAcrossBoundary() {\n        let year = 2026, month = 1, day = 12\n\n        // 01:58 -> previous day\n        let date0158 = makeDate(year: year, month: month, day: day, hour: 1, minute: 58)\n        let logical0158 = DateUtils.getLogicalDate(for: date0158)\n        XCTAssertEqual(logical0158.day, 11, \"01:58 should return previous day\")\n\n        // 01:59 -> previous day\n        let date0159 = makeDate(year: year, month: month, day: day, hour: 1, minute: 59)\n        let logical0159 = DateUtils.getLogicalDate(for: date0159)\n        XCTAssertEqual(logical0159.day, 11, \"01:59 should return previous day\")\n\n        // 02:00 -> current day (boundary)\n        let date0200 = makeDate(year: year, month: month, day: day, hour: 2, minute: 0)\n        let logical0200 = DateUtils.getLogicalDate(for: date0200)\n        XCTAssertEqual(logical0200.day, 12, \"02:00 should return current day\")\n\n        // 02:01 -> current day\n        let date0201 = makeDate(year: year, month: month, day: day, hour: 2, minute: 1)\n        let logical0201 = DateUtils.getLogicalDate(for: date0201)\n        XCTAssertEqual(logical0201.day, 12, \"02:01 should return current day\")\n\n        // 02:02 -> current day\n        let date0202 = makeDate(year: year, month: month, day: day, hour: 2, minute: 2)\n        let logical0202 = DateUtils.getLogicalDate(for: date0202)\n        XCTAssertEqual(logical0202.day, 12, \"02:02 should return current day\")\n    }\n\n    // MARK: - Date Formatting Utilities Tests\n\n    /// Test: formatKorean returns correct Korean format\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatKorean\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \ud615\uc2dd\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatKorean_ReturnsCorrectFormat() {\n        // Given: A specific date\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 15, minute: 30)\n\n        // When: Formatting in Korean\n        let formatted = DateUtils.formatKorean(testDate)\n\n        // Then: Should contain Korean date components\n        XCTAssertTrue(\n            formatted.contains(\"2026\") && formatted.contains(\"1\") && formatted.contains(\"12\"),\n            \"Korean formatted date should contain year, month, and day\"\n        )\n        XCTAssertTrue(\n            formatted.contains(\"\ub144\") || formatted.contains(\"\uc6d4\") || formatted.contains(\"\uc77c\"),\n            \"Korean formatted date should contain Korean characters\"\n        )\n    }\n\n    /// Test: formatDuration returns correct Korean duration strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatDuration\uc774 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc2dc\uac04 \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testFormatDuration_ReturnsCorrectStrings() {\n        // Test hours and minutes\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 450), \"7\uc2dc\uac04 30\ubd84\")\n\n        // Test hours only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 60), \"1\uc2dc\uac04\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 120), \"2\uc2dc\uac04\")\n\n        // Test minutes only\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 45), \"45\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 0), \"0\ubd84\")\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1), \"1\ubd84\")\n    }\n\n    /// Test: daysBetween calculates correct day differences\n    ///\n    /// \ud14c\uc2a4\ud2b8: daysBetween\uc774 \uc62c\ubc14\ub978 \uc77c\uc218 \ucc28\uc774\ub97c \uacc4\uc0b0\ud558\ub294\uc9c0 \ud655\uc778\n    func testDaysBetween_CalculatesCorrectDifferences() {\n        // Given: Two dates\n        let date1 = makeDate(year: 2026, month: 1, day: 12, hour: 10, minute: 0)\n        let date2 = makeDate(year: 2026, month: 1, day: 19, hour: 15, minute: 30)\n\n        // When: Calculating days between\n        let days = DateUtils.daysBetween(from: date1, to: date2)\n\n        // Then: Should return 7 days\n        XCTAssertEqual(days, 7, \"Should calculate 7 days between Jan 12 and Jan 19\")\n    }\n\n    /// Test: relativeDate returns correct Korean relative strings\n    ///\n    /// \ud14c\uc2a4\ud2b8: relativeDate\uac00 \uc62c\ubc14\ub978 \ud55c\uad6d\uc5b4 \uc0c1\ub300 \ub0a0\uc9dc \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\ub294\uc9c0 \ud655\uc778\n    func testRelativeDate_ReturnsCorrectStrings() {\n        // Given: Today's date\n        let today = Date()\n\n        // When/Then: Testing relative dates\n        let todayStr = DateUtils.relativeDate(today)\n        XCTAssertEqual(todayStr, \"\uc624\ub298\", \"Today should return '\uc624\ub298'\")\n\n        let yesterday = today.adding(days: -1)\n        let yesterdayStr = DateUtils.relativeDate(yesterday)\n        XCTAssertEqual(yesterdayStr, \"\uc5b4\uc81c\", \"Yesterday should return '\uc5b4\uc81c'\")\n\n        let tomorrow = today.adding(days: 1)\n        let tomorrowStr = DateUtils.relativeDate(tomorrow)\n        XCTAssertEqual(tomorrowStr, \"\ub0b4\uc77c\", \"Tomorrow should return '\ub0b4\uc77c'\")\n\n        // For dates beyond yesterday/tomorrow, should return formatted date\n        let lastWeek = today.adding(days: -7)\n        let lastWeekStr = DateUtils.relativeDate(lastWeek)\n        XCTAssertNotEqual(lastWeekStr, \"\uc624\ub298\", \"Last week should not return '\uc624\ub298'\")\n        XCTAssertNotEqual(lastWeekStr, \"\uc5b4\uc81c\", \"Last week should not return '\uc5b4\uc81c'\")\n    }\n\n    // MARK: - shouldShowSleepPopup Tests\n\n    /// Test: shouldShowSleepPopup behavior at boundary hours\n    ///\n    /// \ud14c\uc2a4\ud2b8: shouldShowSleepPopup\uc758 \uacbd\uacc4 \uc2dc\uac04 \ub3d9\uc791\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Time-dependent testing challenge\n    /// - \uc774 \uba54\uc11c\ub4dc\ub294 \ud604\uc7ac \uc2dc\uac04\uc744 \uc0ac\uc6a9\ud558\ubbc0\ub85c \uc9c1\uc811 \ud14c\uc2a4\ud2b8\ud558\uae30 \uc5b4\ub824\uc6c0\n    /// - \uc2e4\uc81c \uad6c\ud604\uc5d0\uc11c\ub294 dependency injection\uc73c\ub85c \uc2dc\uac04\uc744 \uc8fc\uc785\ud558\ub294 \uac83\uc774 \uc774\uc0c1\uc801\n    /// - \uc5ec\uae30\uc11c\ub294 \ub85c\uc9c1\uc758 \uae30\ub300 \ub3d9\uc791\uc744 \ubb38\uc11c\ud654\ud558\uace0 \uac04\uc811\uc801\uc73c\ub85c \uac80\uc99d\n    /// \ud83d\udca1 Java \ube44\uad50: Clock.systemUTC()\ub97c MockClock\uc73c\ub85c \ub300\uccb4\ud558\ub294 \uac83\uacfc \uc720\uc0ac\n    func testShouldShowSleepPopup_BehaviorDocumentation() {\n        // Given: Current time\n        let currentHour = Calendar.current.component(.hour, from: Date())\n\n        // When: Calling shouldShowSleepPopup\n        let shouldShow = DateUtils.shouldShowSleepPopup()\n\n        // Then: Should return true if hour >= 6, false otherwise\n        // \ud83d\udcda Expected behavior:\n        // - 00:00 ~ 05:59 -> false (too early, sleep popup should not show)\n        // - 06:00 ~ 23:59 -> true (valid time to show sleep popup)\n        if currentHour >= 6 {\n            XCTAssertTrue(\n                shouldShow,\n                \"shouldShowSleepPopup() should return true when current hour (\\(currentHour)) >= 6\"\n            )\n        } else {\n            XCTAssertFalse(\n                shouldShow,\n                \"shouldShowSleepPopup() should return false when current hour (\\(currentHour)) < 6\"\n            )\n        }\n    }\n\n    /// Test: shouldShowSleepPopup uses promptHour (6 AM), not boundaryHour (2 AM)\n    ///\n    /// \ud14c\uc2a4\ud2b8: shouldShowSleepPopup\uc740 promptHour (6\uc2dc)\ub97c \uc0ac\uc6a9, boundaryHour (2\uc2dc) \uc544\ub2d8\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Separation of Concerns\n    /// - promptHour (6 AM): \uc0ac\uc6a9\uc790\uc5d0\uac8c \ud504\ub86c\ud504\ud2b8\ub97c \ubcf4\uc5ec\uc8fc\ub294 \uc2dc\uac04\n    /// - boundaryHour (2 AM): \uc218\uba74 \ub0a0\uc9dc\ub97c \uacc4\uc0b0\ud558\ub294 \uacbd\uacc4 \uc2dc\uac04\n    /// - These are separate concerns and use different constants\n    func testShouldShowSleepPopup_UsesPromptHourNotBoundaryHour() {\n        // Given: Constants\n        // Then: Verify separation of concerns\n        XCTAssertEqual(Constants.Sleep.boundaryHour, 2, \"Boundary hour should be 2 AM\")\n        XCTAssertEqual(Constants.Sleep.promptHour, 6, \"Prompt hour should be 6 AM\")\n        XCTAssertNotEqual(Constants.Sleep.boundaryHour, Constants.Sleep.promptHour,\n                          \"Boundary and prompt hours should be different\")\n    }\n\n    /// Test: getLogicalDate still uses 2 AM boundary after prompt hour fix\n    ///\n    /// \ud14c\uc2a4\ud2b8: getLogicalDate\ub294 \uc5ec\uc804\ud788 02:00 \uacbd\uacc4\ub97c \uc0ac\uc6a9\ud568\uc744 \ud655\uc778\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Independence of Logic\n    /// - Prompt timing change should not affect sleep date assignment\n    /// - boundaryHour (2 AM) remains unchanged for date logic\n    func testGetLogicalDate_StillUses2AMBoundary_AfterPromptHourFix() {\n        // Given: Time is 01:59 AM on Jan 15\n        let calendar = Calendar.current\n        let jan15_0159 = makeDate(year: 2026, month: 1, day: 15, hour: 1, minute: 59)\n\n        // When: Get logical date\n        let logicalDate = DateUtils.getLogicalDate(for: jan15_0159)\n\n        // Then: Should return Jan 14 (previous day) - using 2 AM boundary\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 14)\n        XCTAssertEqual(\n            calendar.startOfDay(for: logicalDate),\n            calendar.startOfDay(for: expectedDate),\n            \"Sleep at 01:59 should belong to previous day (using 2 AM boundary)\"\n        )\n    }\n\n    // MARK: - Additional Edge Cases for Sleep Boundary Logic\n\n    /// Test: Leap year boundary - Feb 29 to Mar 1\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc724\ub144 \uacbd\uacc4 - 2\uc6d4 29\uc77c\uc5d0\uc11c 3\uc6d4 1\uc77c\ub85c\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Leap Year Edge Case\n    func testGetLogicalDate_LeapYearBoundary_Feb29ToMar1() {\n        // Given: March 1, 2024 at 00:00 (2024 is a leap year)\n        let testDate = makeDate(year: 2024, month: 3, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return February 29, 2024 (leap day)\n        let expectedDate = makeExpectedDate(year: 2024, month: 2, day: 29)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on March 1 in leap year should return Feb 29\"\n        )\n    }\n\n    /// Test: Leap year boundary - Feb 29 at 01:59\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc724\ub144 \uacbd\uacc4 - 2\uc6d4 29\uc77c 01:59\n    func testGetLogicalDate_LeapYearBoundary_Feb29At0159() {\n        // Given: February 29, 2024 at 01:59\n        let testDate = makeDate(year: 2024, month: 2, day: 29, hour: 1, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return February 28, 2024\n        let expectedDate = makeExpectedDate(year: 2024, month: 2, day: 28)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:59 on Feb 29 should return Feb 28\"\n        )\n    }\n\n    /// Test: Non-leap year boundary - Feb 28 to Mar 1\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ud3c9\ub144 \uacbd\uacc4 - 2\uc6d4 28\uc77c\uc5d0\uc11c 3\uc6d4 1\uc77c\ub85c\n    func testGetLogicalDate_NonLeapYearBoundary_Feb28ToMar1() {\n        // Given: March 1, 2025 at 00:00 (2025 is not a leap year)\n        let testDate = makeDate(year: 2025, month: 3, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return February 28, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 2, day: 28)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on March 1 in non-leap year should return Feb 28\"\n        )\n    }\n\n    /// Test: 30-day month boundary - Apr 1 at midnight\n    ///\n    /// \ud14c\uc2a4\ud2b8: 30\uc77c \uc6d4 \uacbd\uacc4 - 4\uc6d4 1\uc77c \uc790\uc815\n    func testGetLogicalDate_30DayMonthBoundary() {\n        // Given: April 1, 2026 at 00:00\n        let testDate = makeDate(year: 2026, month: 4, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return March 31, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 3, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on April 1 should return March 31\"\n        )\n    }\n\n    /// Test: 31-day month boundary - Aug 1 at midnight\n    ///\n    /// \ud14c\uc2a4\ud2b8: 31\uc77c \uc6d4 \uacbd\uacc4 - 8\uc6d4 1\uc77c \uc790\uc815\n    func testGetLogicalDate_31DayMonthBoundary() {\n        // Given: August 1, 2026 at 00:00\n        let testDate = makeDate(year: 2026, month: 8, day: 1, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return July 31, 2026\n        let expectedDate = makeExpectedDate(year: 2026, month: 7, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on August 1 should return July 31\"\n        )\n    }\n\n    /// Test: Year boundary at 01:30\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \uacbd\uacc4 01:30\n    func testGetLogicalDate_YearBoundary_0130() {\n        // Given: January 1, 2026 at 01:30\n        let testDate = makeDate(year: 2026, month: 1, day: 1, hour: 1, minute: 30)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:30 on Jan 1, 2026 should return Dec 31, 2025\"\n        )\n    }\n\n    /// Test: Last day of year at 23:59\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \ub9c8\uc9c0\ub9c9 \ub0a0 23:59\n    func testGetLogicalDate_LastDayOfYear_2359() {\n        // Given: December 31, 2025 at 23:59\n        let testDate = makeDate(year: 2025, month: 12, day: 31, hour: 23, minute: 59)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 31, 2025 (same day)\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 31)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"23:59 on Dec 31 should return Dec 31 (same day)\"\n        )\n    }\n\n    /// Test: Last day of year at 00:00\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ub144 \ub9c8\uc9c0\ub9c9 \ub0a0 00:00\n    func testGetLogicalDate_LastDayOfYear_Midnight() {\n        // Given: December 31, 2025 at 00:00\n        let testDate = makeDate(year: 2025, month: 12, day: 31, hour: 0, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Should return December 30, 2025\n        let expectedDate = makeExpectedDate(year: 2025, month: 12, day: 30)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"Midnight on Dec 31 should return Dec 30\"\n        )\n    }\n\n    // MARK: - Real-world Sleep Tracking Scenarios\n\n    /// Test: Real-world scenario - logging sleep at 8 AM\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc2e4\uc81c \uc2dc\ub098\ub9ac\uc624 - \uc624\uc804 8\uc2dc\uc5d0 \uc218\uba74 \uae30\ub85d\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Real-world Use Case\n    /// - \uc0ac\uc6a9\uc790\uac00 \uc624\uc804 8\uc2dc\uc5d0 \uc77c\uc5b4\ub098\uc11c \uc5b4\uc82f\ubc24 \uc218\uba74\uc744 \uae30\ub85d\n    /// - 8\uc2dc\uc758 \ub17c\ub9ac\uc801 \ub0a0\uc9dc\ub294 \uc624\ub298\uc774\uc9c0\ub9cc, \uae30\ub85d\ud558\ub294 \uc218\uba74\uc740 \uc5b4\uc81c \ub0a0\uc9dc\ub85c \uc800\uc7a5\ub418\uc5b4\uc57c \ud568\n    func testGetLogicalDate_RealWorldScenario_LoggingSleepAt8AM() {\n        // Given: January 12, 2026 at 08:00 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 8, minute: 0)\n\n        // When: Getting logical date (for determining \"today\")\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Logical date is Jan 12 (today)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 12)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"08:00 AM returns current day (Jan 12)\"\n        )\n\n        // \ud83d\udcda Note: When logging sleep at 8 AM, the sleep record should be saved with Jan 11 date\n        // This is handled by the UI/ViewModel, not by getLogicalDate\n    }\n\n    /// Test: Real-world scenario - late night recording at 1 AM\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc2e4\uc81c \uc2dc\ub098\ub9ac\uc624 - \uc0c8\ubcbd 1\uc2dc\uc5d0 \uc218\uba74 \uae30\ub85d\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Late Night Recording\n    /// - \uc0ac\uc6a9\uc790\uac00 \uc0c8\ubcbd 1\uc2dc\uc5d0 \uae68\uc5b4\uc11c \uc218\uba74\uc744 \uae30\ub85d\n    /// - 1\uc2dc\uc758 \ub17c\ub9ac\uc801 \ub0a0\uc9dc\ub294 \uc5b4\uc81c\uc774\ubbc0\ub85c, \uc218\uba74\ub3c4 \uc5b4\uc81c \ub0a0\uc9dc\ub85c \uc800\uc7a5\n    func testGetLogicalDate_RealWorldScenario_LateNightRecordingAt1AM() {\n        // Given: January 12, 2026 at 01:00 AM\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 0)\n\n        // When: Getting logical date\n        let logicalDate = DateUtils.getLogicalDate(for: testDate)\n\n        // Then: Logical date is Jan 11 (yesterday)\n        let expectedDate = makeExpectedDate(year: 2026, month: 1, day: 11)\n        XCTAssertEqual(\n            logicalDate.yyyyMMdd,\n            expectedDate.yyyyMMdd,\n            \"01:00 AM returns previous day (Jan 11)\"\n        )\n\n        // \ud83d\udcda Note: Sleep recorded at 1 AM is saved with yesterday's date (Jan 11)\n    }\n\n    /// Test: Real-world scenario - boundary crossing at exactly 2 AM\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc2e4\uc81c \uc2dc\ub098\ub9ac\uc624 - \uc815\ud655\ud788 \uc0c8\ubcbd 2\uc2dc\uc758 \uacbd\uacc4\n    func testGetLogicalDate_RealWorldScenario_BoundaryCrossingAt2AM() {\n        // Given: Dates around 2 AM boundary\n        let before = makeDate(year: 2026, month: 1, day: 12, hour: 1, minute: 59)\n        let boundary = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0)\n        let after = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 1)\n\n        // When: Getting logical dates\n        let logicalBefore = DateUtils.getLogicalDate(for: before)\n        let logicalBoundary = DateUtils.getLogicalDate(for: boundary)\n        let logicalAfter = DateUtils.getLogicalDate(for: after)\n\n        // Then: Before returns yesterday, boundary and after return today\n        XCTAssertEqual(logicalBefore.day, 11, \"01:59 returns yesterday\")\n        XCTAssertEqual(logicalBoundary.day, 12, \"02:00 returns today (boundary)\")\n        XCTAssertEqual(logicalAfter.day, 12, \"02:01 returns today\")\n\n        // \ud83d\udcda Note: The boundary is precise - even 1 minute difference matters\n    }\n\n    // MARK: - getSleepDate Additional Tests\n\n    /// Test: getSleepDate with various timezone scenarios\n    ///\n    /// \ud14c\uc2a4\ud2b8: getSleepDate\uc758 \ub2e4\uc591\ud55c \uc2dc\uac04\ub300 \uc2dc\ub098\ub9ac\uc624\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Timezone Independence\n    /// - getLogicalDate/getSleepDate\ub294 \ud604\uc7ac \uc2dc\uc2a4\ud15c timezone \uc0ac\uc6a9\n    /// - \ub2e4\ub978 timezone\uc5d0\uc11c\ub3c4 \ub3d9\uc77c\ud558\uac8c \ub3d9\uc791\ud574\uc57c \ud568\n    func testGetSleepDate_TimeZoneIndependence() {\n        // Given: Dates at boundary hours\n        let midnight = makeDate(year: 2026, month: 1, day: 12, hour: 0, minute: 0)\n        let twoAM = makeDate(year: 2026, month: 1, day: 12, hour: 2, minute: 0)\n\n        // When: Getting sleep dates\n        let sleepDateMidnight = DateUtils.getSleepDate(for: midnight)\n        let sleepDateTwoAM = DateUtils.getSleepDate(for: twoAM)\n\n        // Then: Should follow boundary logic regardless of timezone\n        XCTAssertEqual(sleepDateMidnight.day, 11, \"Midnight returns previous day\")\n        XCTAssertEqual(sleepDateTwoAM.day, 12, \"2 AM returns current day\")\n\n        // \ud83d\udcda Note: This test uses system timezone. In production, ensure\n        // consistent timezone handling across different user devices\n    }\n\n    /// Test: getSleepDate multiple calls return consistent results\n    ///\n    /// \ud14c\uc2a4\ud2b8: getSleepDate\uc758 \uc5ec\ub7ec \ud638\ucd9c\uc774 \uc77c\uad00\ub41c \uacb0\uacfc\ub97c \ubc18\ud658\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Idempotency\n    func testGetSleepDate_MultipleCallsConsistent() {\n        // Given: A specific date\n        let testDate = makeDate(year: 2026, month: 1, day: 12, hour: 3, minute: 30)\n\n        // When: Calling getSleepDate multiple times\n        let result1 = DateUtils.getSleepDate(for: testDate)\n        let result2 = DateUtils.getSleepDate(for: testDate)\n        let result3 = DateUtils.getSleepDate(for: testDate)\n\n        // Then: All calls should return the same date\n        XCTAssertEqual(result1.yyyyMMdd, result2.yyyyMMdd)\n        XCTAssertEqual(result2.yyyyMMdd, result3.yyyyMMdd)\n        XCTAssertEqual(result1.yyyyMMdd, result3.yyyyMMdd)\n\n        // \ud83d\udcda Note: Pure function - same input always produces same output\n    }\n\n    // MARK: - Edge Cases for Date Formatting\n\n    /// Test: formatDuration with large values\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatDuration\uc758 \ud070 \uac12 \ucc98\ub9ac\n    func testFormatDuration_LargeValues() {\n        // Test 24 hours\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1440), \"24\uc2dc\uac04\")\n\n        // Test more than 24 hours\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1500), \"25\uc2dc\uac04\")\n\n        // Test multiple days\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 2880), \"48\uc2dc\uac04\")\n    }\n\n    /// Test: formatDuration with edge values\n    ///\n    /// \ud14c\uc2a4\ud2b8: formatDuration\uc758 \uacbd\uacc4\uac12 \ucc98\ub9ac\n    func testFormatDuration_EdgeValues() {\n        // Test 1 minute\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1), \"1\ubd84\")\n\n        // Test 59 minutes\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 59), \"59\ubd84\")\n\n        // Test exactly 1 hour\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 60), \"1\uc2dc\uac04\")\n\n        // Test 1 hour 1 minute\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 61), \"1\uc2dc\uac04 1\ubd84\")\n\n        // Test 23 hours 59 minutes\n        XCTAssertEqual(DateUtils.formatDuration(minutes: 1439), \"23\uc2dc\uac04 59\ubd84\")\n    }\n\n    /// Test: daysBetween with same day\n    ///\n    /// \ud14c\uc2a4\ud2b8: daysBetween\uc758 \uac19\uc740 \ub0a0 \ucc98\ub9ac\n    func testDaysBetween_SameDay() {\n        // Given: Same date at different times\n        let date1 = makeDate(year: 2026, month: 1, day: 12, hour: 8, minute: 0)\n        let date2 = makeDate(year: 2026, month: 1, day: 12, hour: 20, minute: 0)\n\n        // When: Calculating days between\n        let days = DateUtils.daysBetween(from: date1, to: date2)\n\n        // Then: Should return 0 days (same day)\n        XCTAssertEqual(days, 0, \"Same day should return 0 days\")\n    }\n\n    /// Test: daysBetween with reversed dates\n    ///\n    /// \ud14c\uc2a4\ud2b8: daysBetween\uc758 \uc5ed\uc21c \ub0a0\uc9dc \ucc98\ub9ac\n    func testDaysBetween_ReversedDates() {\n        // Given: Two dates in reverse order\n        let date1 = makeDate(year: 2026, month: 1, day: 12, hour: 10, minute: 0)\n        let date2 = makeDate(year: 2026, month: 1, day: 19, hour: 15, minute: 30)\n\n        // When: Calculating days between (reversed)\n        let daysForward = DateUtils.daysBetween(from: date1, to: date2)\n        let daysReverse = DateUtils.daysBetween(from: date2, to: date1)\n\n        // Then: Should return absolute value (7 days in both cases)\n        XCTAssertEqual(daysForward, 7)\n        XCTAssertEqual(daysReverse, 7)\n        XCTAssertEqual(daysForward, daysReverse, \"daysBetween should return absolute value\")\n    }\n}\n",
        "last_modified": "2026-01-18T17:07:01.350554"
      },
      "task_intent": {
        "title": "009-sleep-tracking-with-5-status-system",
        "description": "Sleep logging with 5-status tracking (bad, soso, good, excellent, oversleep), duration input, wake time prompts, and correlation with other health metrics. Automatic morning prompt to log previous night's sleep.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-12T19:14:55.184291",
  "last_updated": "2026-01-14T21:03:40.601640"
}