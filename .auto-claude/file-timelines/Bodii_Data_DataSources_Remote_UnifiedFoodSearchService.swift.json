{
  "file_path": "Bodii/Data/DataSources/Remote/UnifiedFoodSearchService.swift",
  "main_branch_history": [],
  "task_views": {
    "005-korean-food-database-integration": {
      "task_id": "005-korean-food-database-integration",
      "branch_point": {
        "commit_hash": "c44bfbcd7c1699b176a8bb155e8c35f43ebd4ad9",
        "content": "",
        "timestamp": "2026-01-13T07:46:23.878686"
      },
      "worktree_state": {
        "content": "//\n//  UnifiedFoodSearchService.swift\n//  Bodii\n//\n//  Created by Auto-Claude on 2026-01-13.\n//\n\n// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Unified Search Service\n// \uc5ec\ub7ec \ub370\uc774\ud130 \uc18c\uc2a4\ub97c \ud1b5\ud569\ud558\uc5ec \ub2e8\uc77c \uac80\uc0c9 \uc778\ud130\ud398\uc774\uc2a4 \uc81c\uacf5\n// \ud83d\udca1 Java \ube44\uad50: Facade Pattern + Strategy Pattern\uc758 \uc870\ud569\n\nimport Foundation\n\n/// \ud1b5\ud569 \uc2dd\ud488 \uac80\uc0c9 \uc11c\ube44\uc2a4\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Multi-Source Search Strategy\n/// \uc2dd\uc57d\ucc98 API\uc640 USDA API\ub97c \ud1b5\ud569\ud558\uc5ec \ucd5c\uc801\uc758 \uac80\uc0c9 \uacb0\uacfc \uc81c\uacf5\n/// \ud55c\uad6d \uc74c\uc2dd\uc740 \uc2dd\uc57d\ucc98 \uc6b0\uc120, \uc678\uad6d \uc74c\uc2dd\uc740 USDA \uc6b0\uc120 \uc804\ub7b5\n/// \ud83d\udca1 Java \ube44\uad50: Composite Pattern\uc73c\ub85c \uc5ec\ub7ec Repository\ub97c \uc870\ud569\ud558\ub294 \ud328\ud134\uacfc \uc720\uc0ac\n///\n/// **\uac80\uc0c9 \uc804\ub7b5:**\n/// 1. \uac80\uc0c9\uc5b4 \ubd84\uc11d (\ud55c\uae00/\uc601\ubb38 \ud310\ub2e8)\n/// 2. \ud55c\uae00 \uac80\uc0c9\uc5b4: \uc2dd\uc57d\ucc98 \uba3c\uc800 \u2192 USDA \ud3f4\ubc31\n/// 3. \uc601\ubb38 \uac80\uc0c9\uc5b4: \uc2dd\uc57d\ucc98 + USDA \ubcd1\ub82c \uac80\uc0c9 (USDA \uc6b0\uc120)\n/// 4. \uacb0\uacfc \ubcd1\ud569 (\ud55c\uad6d \uc74c\uc2dd\uc774 \ud56d\uc0c1 \uc0c1\uc704\uc5d0 \ud45c\uc2dc)\n/// 5. \uc911\ubcf5 \uc81c\uac70 (apiCode \uae30\uc900)\n///\n/// **\uc5d0\ub7ec \ucc98\ub9ac \ubc0f \uc7ac\uc2dc\ub3c4:**\n/// - \uac01 API \ud638\ucd9c\uc740 \ucd5c\ub300 2\ud68c \uc7ac\uc2dc\ub3c4 (\uc9c0\uc218 \ubc31\uc624\ud504: 1\ucd08, 2\ucd08)\n/// - \uc77c\uc2dc\uc801 \ub124\ud2b8\uc6cc\ud06c \uc5d0\ub7ec(timeout, connection lost)\ub294 \uc790\ub3d9 \uc7ac\uc2dc\ub3c4\n/// - \uc601\uad6c\uc801 \uc5d0\ub7ec(401, 400, parsing error)\ub294 \uc989\uc2dc \ud3f4\ubc31\n/// - \ud55c\ucabd API \uc2e4\ud328 \uc2dc \ub2e4\ub978 \ucabd \uacb0\uacfc \ubc18\ud658\n/// - \uc591\ucabd API \ubaa8\ub450 \uc2e4\ud328 \uc2dc \ube48 \ubc30\uc5f4 \ubc18\ud658 (graceful degradation)\n/// - \ubaa8\ub4e0 \uc5d0\ub7ec\ub294 \ub514\ubc84\uadf8 \ub85c\uadf8\uc5d0 \uc0c1\uc138 \uae30\ub85d\n///\n/// **\uc0ac\uc6a9 \uc608\uc2dc:**\n/// ```swift\n/// let service = UnifiedFoodSearchService()\n///\n/// // \ud55c\uad6d \uc74c\uc2dd \uac80\uc0c9 (\uc2dd\uc57d\ucc98 \uc6b0\uc120)\n/// let koreanFoods = try await service.searchFoods(query: \"\uae40\uce58\ucc0c\uac1c\", limit: 20)\n///\n/// // \uc678\uad6d \uc74c\uc2dd \uac80\uc0c9 (USDA \ud3ec\ud568)\n/// let internationalFoods = try await service.searchFoods(query: \"chicken breast\", limit: 20)\n/// ```\nfinal class UnifiedFoodSearchService {\n\n    // MARK: - Properties\n\n    /// \uc2dd\uc57d\ucc98 API \uc11c\ube44\uc2a4\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Dependency Injection\n    /// \uc678\ubd80\uc5d0\uc11c \uc8fc\uc785\ubc1b\uc544 \ud14c\uc2a4\ud2b8 \uc2dc Mock\uc73c\ub85c \uad50\uccb4 \uac00\ub2a5\n    /// \ud83d\udca1 Java \ube44\uad50: @Autowired field injection\n    private let kfdaService: KFDAFoodAPIService\n\n    /// USDA API \uc11c\ube44\uc2a4\n    ///\n    /// \uc678\ubd80\uc5d0\uc11c \uc8fc\uc785\ubc1b\uc544 \ud14c\uc2a4\ud2b8 \uc2dc Mock\uc73c\ub85c \uad50\uccb4 \uac00\ub2a5\n    private let usdaService: USDAFoodAPIService\n\n    /// \uc2dd\uc57d\ucc98 DTO to Domain \ub9e4\ud37c\n    private let kfdaMapper: KFDAFoodMapper\n\n    /// USDA DTO to Domain \ub9e4\ud37c\n    private let usdaMapper: USDAFoodMapper\n\n    // MARK: - Initialization\n\n    /// UnifiedFoodSearchService \ucd08\uae30\ud654\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Constructor Injection\n    /// \ubaa8\ub4e0 \uc758\uc874\uc131\uc744 \uc0dd\uc131\uc790\ub97c \ud1b5\ud574 \uc8fc\uc785\ubc1b\uc544 \ud14c\uc2a4\ud2b8 \uc6a9\uc774\uc131 \ud5a5\uc0c1\n    /// \ud83d\udca1 Java \ube44\uad50: @Inject constructor\uc640 \uc720\uc0ac\n    ///\n    /// - Parameters:\n    ///   - kfdaService: \uc2dd\uc57d\ucc98 API \uc11c\ube44\uc2a4\n    ///   - usdaService: USDA API \uc11c\ube44\uc2a4\n    ///   - kfdaMapper: \uc2dd\uc57d\ucc98 \ub9e4\ud37c (\uae30\ubcf8\uac12: KFDAFoodMapper())\n    ///   - usdaMapper: USDA \ub9e4\ud37c (\uae30\ubcf8\uac12: USDAFoodMapper())\n    init(\n        kfdaService: KFDAFoodAPIService = KFDAFoodAPIService(),\n        usdaService: USDAFoodAPIService = USDAFoodAPIService(),\n        kfdaMapper: KFDAFoodMapper = KFDAFoodMapper(),\n        usdaMapper: USDAFoodMapper = USDAFoodMapper()\n    ) {\n        self.kfdaService = kfdaService\n        self.usdaService = usdaService\n        self.kfdaMapper = kfdaMapper\n        self.usdaMapper = usdaMapper\n    }\n\n    // MARK: - Public Methods\n\n    /// \ud1b5\ud569 \uc2dd\ud488 \uac80\uc0c9\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Intelligent Multi-Source Search\n    /// \uac80\uc0c9\uc5b4\ub97c \ubd84\uc11d\ud558\uc5ec \ucd5c\uc801\uc758 \ub370\uc774\ud130 \uc18c\uc2a4 \uc120\ud0dd \ubc0f \ubcd1\ud569\n    /// \ud83d\udca1 Java \ube44\uad50: CompletableFuture\ub97c \ud65c\uc6a9\ud55c \ubcd1\ub82c \ucc98\ub9ac\uc640 \uc720\uc0ac\n    ///\n    /// **\uac80\uc0c9 \ub85c\uc9c1:**\n    /// 1. \uac80\uc0c9\uc5b4 \ubd84\uc11d (\ud55c\uae00 \ud3ec\ud568 \uc5ec\ubd80 \uccb4\ud06c)\n    /// 2. \ud55c\uae00 \uac80\uc0c9\uc5b4:\n    ///    - \uc2dd\uc57d\ucc98 API \uba3c\uc800 \uac80\uc0c9\n    ///    - \uacb0\uacfc \ubd80\uc871 \uc2dc(< 5\uac1c) USDA\ub3c4 \uac80\uc0c9\ud558\uc5ec \ucd94\uac00\n    /// 3. \uc601\ubb38 \uac80\uc0c9\uc5b4:\n    ///    - \uc2dd\uc57d\ucc98\uc640 USDA \ubcd1\ub82c \uac80\uc0c9 (\uc131\ub2a5 \ucd5c\uc801\ud654)\n    ///    - USDA \uacb0\uacfc\ub97c \uc0c1\uc704\uc5d0 \ubc30\uce58\n    /// 4. \uc911\ubcf5 \uc81c\uac70 (apiCode \uae30\uc900)\n    /// 5. limit \uc801\uc6a9\n    ///\n    /// - Parameters:\n    ///   - query: \uac80\uc0c9\uc5b4 (\uc608: \"\uae40\uce58\ucc0c\uac1c\", \"chicken\")\n    ///   - limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218 (\uae30\ubcf8\uac12: 20)\n    ///   - offset: \uc624\ud504\uc14b (\ud604\uc7ac \ubc84\uc804\uc5d0\uc11c\ub294 \ubbf8\uc9c0\uc6d0, \ucd94\ud6c4 \uad6c\ud604)\n    ///\n    /// - Returns: \ud1b5\ud569 \uac80\uc0c9 \uacb0\uacfc (Food \ub3c4\uba54\uc778 \uc5d4\ud2f0\ud2f0 \ubc30\uc5f4)\n    ///\n    /// - Note: \uac01 API\ub294 \ucd5c\ub300 2\ud68c \uc7ac\uc2dc\ub3c4\ud558\uba70, \ud55c\ucabd API \uc2e4\ud328 \uc2dc \ub2e4\ub978 \ucabd \uacb0\uacfc\ub9cc \ubc18\ud658 (graceful degradation)\n    ///         \uc591\ucabd API \ubaa8\ub450 \uc2e4\ud328 \uc2dc \ube48 \ubc30\uc5f4 \ubc18\ud658 (\uc5d0\ub7ec\ub97c \ub358\uc9c0\uc9c0 \uc54a\uc74c)\n    ///\n    /// - Example:\n    /// ```swift\n    /// // \ud55c\uad6d \uc74c\uc2dd \uac80\uc0c9\n    /// let foods1 = try await service.searchFoods(query: \"\ub41c\uc7a5\ucc0c\uac1c\")\n    /// // \u2192 \uc2dd\uc57d\ucc98 \uc6b0\uc120, \uacb0\uacfc \ubd80\uc871 \uc2dc USDA \ucd94\uac00\n    ///\n    /// // \uc678\uad6d \uc74c\uc2dd \uac80\uc0c9\n    /// let foods2 = try await service.searchFoods(query: \"apple\")\n    /// // \u2192 \uc2dd\uc57d\ucc98 + USDA \ubcd1\ub82c \uac80\uc0c9, USDA \uc6b0\uc120 \uc815\ub82c\n    /// ```\n    func searchFoods(\n        query: String,\n        limit: Int = 20,\n        offset: Int = 0\n    ) async throws -> [Food] {\n\n        // \uc785\ub825 \uac80\uc99d\n        guard !query.trimmingCharacters(in: .whitespaces).isEmpty else {\n            throw FoodSearchError.invalidQuery(\"\uac80\uc0c9\uc5b4\uac00 \ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4.\")\n        }\n\n        // \uac80\uc0c9\uc5b4 \ubd84\uc11d: \ud55c\uae00\uc774 \ud3ec\ud568\ub418\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\n        let containsKorean = containsKoreanCharacters(query)\n\n        var allFoods: [Food] = []\n\n        if containsKorean {\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Sequential Search with Fallback\n            // \ud55c\uae00 \uac80\uc0c9\uc5b4\ub294 \uc2dd\uc57d\ucc98 \uc6b0\uc120 \u2192 USDA \ud3f4\ubc31 \uc804\ub7b5\n            // \ud83d\udca1 Java \ube44\uad50: Circuit Breaker + Fallback pattern\n\n            // 1\ub2e8\uacc4: \uc2dd\uc57d\ucc98 \uac80\uc0c9 (\uc7ac\uc2dc\ub3c4 \ud3ec\ud568)\n            let kfdaFoods = await searchKFDA(query: query, limit: limit)\n\n            // 2\ub2e8\uacc4: \uc2dd\uc57d\ucc98 \uacb0\uacfc\uac00 \ucda9\ubd84\ud558\uba74 \uadf8\ub300\ub85c \ubc18\ud658\n            if kfdaFoods.count >= 5 {\n                allFoods = kfdaFoods\n\n                #if DEBUG\n                print(\"\u2705 Korean query: Sufficient KFDA results (\\(kfdaFoods.count) items)\")\n                #endif\n\n            } else {\n                // 3\ub2e8\uacc4: \uacb0\uacfc\uac00 \ubd80\uc871\ud558\uba74 USDA\ub3c4 \uac80\uc0c9\ud558\uc5ec \ucd94\uac00\n                #if DEBUG\n                print(\"\u26a0\ufe0f Korean query: Insufficient KFDA results (\\(kfdaFoods.count) items), searching USDA as fallback\")\n                #endif\n\n                let usdaFoods = await searchUSDA(query: query, limit: limit - kfdaFoods.count)\n\n                // 4\ub2e8\uacc4: \ud55c\uad6d \uc74c\uc2dd \uba3c\uc800, \uc678\uad6d \uc74c\uc2dd \ub098\uc911\uc5d0\n                allFoods = kfdaFoods + usdaFoods\n\n                #if DEBUG\n                if kfdaFoods.isEmpty && usdaFoods.isEmpty {\n                    print(\"\u274c Both KFDA and USDA search failed - returning empty results\")\n                } else {\n                    print(\"\u2705 Fallback successful: \\(kfdaFoods.count) KFDA + \\(usdaFoods.count) USDA = \\(allFoods.count) total\")\n                }\n                #endif\n            }\n\n        } else {\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Parallel Search for Performance\n            // \uc601\ubb38 \uac80\uc0c9\uc5b4\ub294 \uc591\ucabd API\ub97c \ubcd1\ub82c\ub85c \uac80\uc0c9\ud558\uc5ec \uc131\ub2a5 \ucd5c\uc801\ud654\n            // \ud83d\udca1 Java \ube44\uad50: CompletableFuture.allOf()\uc640 \uc720\uc0ac\n\n            #if DEBUG\n            print(\"\ud83d\udd04 English query: Searching KFDA and USDA in parallel\")\n            #endif\n\n            // \ubcd1\ub82c \uac80\uc0c9 (async let\uc73c\ub85c \ub3d9\uc2dc \uc2e4\ud589)\n            async let kfdaFoodsTask = searchKFDA(query: query, limit: limit)\n            async let usdaFoodsTask = searchUSDA(query: query, limit: limit)\n\n            let (kfdaFoods, usdaFoods) = await (kfdaFoodsTask, usdaFoodsTask)\n\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Result Merging Strategy\n            // \uc601\ubb38 \uac80\uc0c9\uc5b4\uc758 \uacbd\uc6b0 USDA \uacb0\uacfc\uac00 \ub354 \uc815\ud655\ud560 \uac00\ub2a5\uc131\uc774 \ub192\uc74c\n            // \ub530\ub77c\uc11c USDA \uacb0\uacfc\ub97c \uba3c\uc800 \ubc30\uce58\ud558\ub418, \ud55c\uad6d \uc74c\uc2dd\ub3c4 \ud3ec\ud568\n            // \ud83d\udca1 Java \ube44\uad50: Stream.concat() + distinct()\n\n            // USDA \uba3c\uc800, \uc2dd\uc57d\ucc98 \ub098\uc911\uc5d0 (\uc678\uad6d \uc74c\uc2dd \uc6b0\uc120)\n            allFoods = usdaFoods + kfdaFoods\n\n            #if DEBUG\n            if kfdaFoods.isEmpty && usdaFoods.isEmpty {\n                print(\"\u274c Both KFDA and USDA search failed for English query\")\n            } else {\n                print(\"\u2705 Parallel search successful: \\(usdaFoods.count) USDA + \\(kfdaFoods.count) KFDA = \\(allFoods.count) total\")\n            }\n            #endif\n        }\n\n        // \uc911\ubcf5 \uc81c\uac70 (apiCode \uae30\uc900)\n        let deduplicatedFoods = deduplicateFoods(allFoods)\n\n        // limit \uc801\uc6a9\n        let limitedFoods = Array(deduplicatedFoods.prefix(limit))\n\n        // \uacb0\uacfc\uac00 \uc5c6\uc73c\uba74 \uc5d0\ub7ec \ub358\uc9c0\uae30 (\uc120\ud0dd\uc801)\n        // \ub610\ub294 \ube48 \ubc30\uc5f4 \ubc18\ud658 (graceful)\n        // \ud604\uc7ac\ub294 \ube48 \ubc30\uc5f4 \ubc18\ud658\uc73c\ub85c \uad6c\ud604\n        return limitedFoods\n    }\n\n    // MARK: - Private Methods\n\n    /// \uc2dd\uc57d\ucc98 API \uac80\uc0c9 (\uc5d0\ub7ec \ucc98\ub9ac \ubc0f \uc7ac\uc2dc\ub3c4 \ud3ec\ud568)\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Retry Logic with Exponential Backoff\n    /// API \uc5d0\ub7ec \ubc1c\uc0dd \uc2dc \uc9c0\uc218 \ubc31\uc624\ud504\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc790\ub3d9 \uc7ac\uc2dc\ub3c4\n    /// \ucd5c\ub300 2\ud68c \uc7ac\uc2dc\ub3c4 \ud6c4\uc5d0\ub3c4 \uc2e4\ud328\ud558\uba74 \uc5d0\ub7ec\ub97c \uc0c1\uc704\ub85c \uc804\ub2ec\n    /// \ud83d\udca1 Java \ube44\uad50: Spring Retry\uc758 @Retryable\uacfc \uc720\uc0ac\n    ///\n    /// - Parameters:\n    ///   - query: \uac80\uc0c9\uc5b4\n    ///   - limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218\n    ///   - retryCount: \ud604\uc7ac \uc7ac\uc2dc\ub3c4 \ud69f\uc218 (\ub0b4\ubd80\uc6a9)\n    ///\n    /// - Returns: \uac80\uc0c9 \uacb0\uacfc (\uc5d0\ub7ec \uc2dc \ube48 \ubc30\uc5f4)\n    ///\n    /// - Throws: \uc7ac\uc2dc\ub3c4 \ud6c4\uc5d0\ub3c4 \uc2e4\ud328 \uc2dc FoodSearchError\n    private func searchKFDA(\n        query: String,\n        limit: Int,\n        retryCount: Int = 0\n    ) async -> [Food] {\n        do {\n            // KFDA API\ub294 \uc778\ub371\uc2a4 \ubc94\uc704 \uc0ac\uc6a9 (1-based)\n            let endIdx = limit\n            let response = try await kfdaService.searchFoods(\n                query: query,\n                startIdx: 1,\n                endIdx: endIdx\n            )\n\n            // DTO\ub97c \ub3c4\uba54\uc778 \uc5d4\ud2f0\ud2f0\ub85c \ubcc0\ud658\n            let foods = kfdaMapper.toDomainArray(from: response.foods)\n\n            #if DEBUG\n            print(\"\u2705 KFDA search success: \\(foods.count) foods found for '\\(query)' (retry: \\(retryCount))\")\n            #endif\n\n            return foods\n\n        } catch {\n            // \uc5d0\ub7ec \ubd84\uc11d \ubc0f \ub85c\uae45\n            let errorType = classifyError(error)\n\n            #if DEBUG\n            print(\"\u26a0\ufe0f KFDA search failed for '\\(query)': \\(errorType) - \\(error.localizedDescription)\")\n            #endif\n\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Retry Strategy\n            // \uc77c\uc2dc\uc801 \ub124\ud2b8\uc6cc\ud06c \uc5d0\ub7ec\ub294 \uc7ac\uc2dc\ub3c4, \uc601\uad6c\uc801 \uc5d0\ub7ec\ub294 \uc989\uc2dc \ubc18\ud658\n            // \ud83d\udca1 Java \ube44\uad50: Resilience4j\uc758 retry pattern\uacfc \uc720\uc0ac\n\n            let maxRetries = Constants.API.KFDA.maxRetries\n            let shouldRetry = retryCount < maxRetries && isRetryableError(error)\n\n            if shouldRetry {\n                // \uc9c0\uc218 \ubc31\uc624\ud504: 1\ucd08, 2\ucd08, 4\ucd08...\n                let delay = pow(2.0, Double(retryCount))\n\n                #if DEBUG\n                print(\"\ud83d\udd04 Retrying KFDA search in \\(delay)s... (attempt \\(retryCount + 1)/\\(maxRetries))\")\n                #endif\n\n                try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n\n                // \uc7ac\uc2dc\ub3c4\n                return await searchKFDA(query: query, limit: limit, retryCount: retryCount + 1)\n            }\n\n            // \uc7ac\uc2dc\ub3c4 \ubd88\uac00\ub2a5\ud558\uac70\ub098 \ucd5c\ub300 \uc7ac\uc2dc\ub3c4 \ud69f\uc218 \ucd08\uacfc\n            #if DEBUG\n            print(\"\u274c KFDA search failed after \\(retryCount) retries for '\\(query)'\")\n            #endif\n\n            // \uc5d0\ub7ec \ubc1c\uc0dd \uc2dc \ube48 \ubc30\uc5f4 \ubc18\ud658 (graceful degradation)\n            // \uc0c1\uc704 \ub808\ubca8\uc5d0\uc11c USDA \ud3f4\ubc31\uc774 \uc791\ub3d9\ud568\n            return []\n        }\n    }\n\n    /// USDA API \uac80\uc0c9 (\uc5d0\ub7ec \ucc98\ub9ac \ubc0f \uc7ac\uc2dc\ub3c4 \ud3ec\ud568)\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Retry Logic with Exponential Backoff\n    /// API \uc5d0\ub7ec \ubc1c\uc0dd \uc2dc \uc9c0\uc218 \ubc31\uc624\ud504\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc790\ub3d9 \uc7ac\uc2dc\ub3c4\n    /// \ucd5c\ub300 2\ud68c \uc7ac\uc2dc\ub3c4 \ud6c4\uc5d0\ub3c4 \uc2e4\ud328\ud558\uba74 \uc5d0\ub7ec\ub97c \uc0c1\uc704\ub85c \uc804\ub2ec\n    /// \ud83d\udca1 Java \ube44\uad50: Spring Retry\uc758 @Retryable\uacfc \uc720\uc0ac\n    ///\n    /// - Parameters:\n    ///   - query: \uac80\uc0c9\uc5b4\n    ///   - limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218\n    ///   - retryCount: \ud604\uc7ac \uc7ac\uc2dc\ub3c4 \ud69f\uc218 (\ub0b4\ubd80\uc6a9)\n    ///\n    /// - Returns: \uac80\uc0c9 \uacb0\uacfc (\uc5d0\ub7ec \uc2dc \ube48 \ubc30\uc5f4)\n    ///\n    /// - Throws: \uc7ac\uc2dc\ub3c4 \ud6c4\uc5d0\ub3c4 \uc2e4\ud328 \uc2dc FoodSearchError\n    private func searchUSDA(\n        query: String,\n        limit: Int,\n        retryCount: Int = 0\n    ) async -> [Food] {\n        do {\n            // USDA API\ub294 \ud398\uc774\uc9c0 \ubc88\ud638 \uc0ac\uc6a9 (1-based)\n            let response = try await usdaService.searchFoods(\n                query: query,\n                pageSize: limit,\n                pageNumber: 1\n            )\n\n            // DTO\ub97c \ub3c4\uba54\uc778 \uc5d4\ud2f0\ud2f0\ub85c \ubcc0\ud658\n            let foods = usdaMapper.toDomainArray(from: response.foods ?? [])\n\n            #if DEBUG\n            print(\"\u2705 USDA search success: \\(foods.count) foods found for '\\(query)' (retry: \\(retryCount))\")\n            #endif\n\n            return foods\n\n        } catch {\n            // \uc5d0\ub7ec \ubd84\uc11d \ubc0f \ub85c\uae45\n            let errorType = classifyError(error)\n\n            #if DEBUG\n            print(\"\u26a0\ufe0f USDA search failed for '\\(query)': \\(errorType) - \\(error.localizedDescription)\")\n            #endif\n\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Retry Strategy\n            // \uc77c\uc2dc\uc801 \ub124\ud2b8\uc6cc\ud06c \uc5d0\ub7ec\ub294 \uc7ac\uc2dc\ub3c4, \uc601\uad6c\uc801 \uc5d0\ub7ec\ub294 \uc989\uc2dc \ubc18\ud658\n            // \ud83d\udca1 Java \ube44\uad50: Resilience4j\uc758 retry pattern\uacfc \uc720\uc0ac\n\n            let maxRetries = Constants.API.USDA.maxRetries\n            let shouldRetry = retryCount < maxRetries && isRetryableError(error)\n\n            if shouldRetry {\n                // \uc9c0\uc218 \ubc31\uc624\ud504: 1\ucd08, 2\ucd08, 4\ucd08...\n                let delay = pow(2.0, Double(retryCount))\n\n                #if DEBUG\n                print(\"\ud83d\udd04 Retrying USDA search in \\(delay)s... (attempt \\(retryCount + 1)/\\(maxRetries))\")\n                #endif\n\n                try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n\n                // \uc7ac\uc2dc\ub3c4\n                return await searchUSDA(query: query, limit: limit, retryCount: retryCount + 1)\n            }\n\n            // \uc7ac\uc2dc\ub3c4 \ubd88\uac00\ub2a5\ud558\uac70\ub098 \ucd5c\ub300 \uc7ac\uc2dc\ub3c4 \ud69f\uc218 \ucd08\uacfc\n            #if DEBUG\n            print(\"\u274c USDA search failed after \\(retryCount) retries for '\\(query)'\")\n            #endif\n\n            // \uc5d0\ub7ec \ubc1c\uc0dd \uc2dc \ube48 \ubc30\uc5f4 \ubc18\ud658 (graceful degradation)\n            return []\n        }\n    }\n\n    /// \uc5d0\ub7ec\uac00 \uc7ac\uc2dc\ub3c4 \uac00\ub2a5\ud55c\uc9c0 \ud310\ub2e8\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Retry Decision Logic\n    /// \uc77c\uc2dc\uc801 \ub124\ud2b8\uc6cc\ud06c \ubb38\uc81c\ub294 \uc7ac\uc2dc\ub3c4 \uac00\ub2a5, \uc601\uad6c\uc801 \uc5d0\ub7ec\ub294 \ubd88\uac00\ub2a5\n    /// \ud83d\udca1 Java \ube44\uad50: Spring Retry\uc758 RetryPolicy\uc640 \uc720\uc0ac\n    ///\n    /// - Parameter error: \ubc1c\uc0dd\ud55c \uc5d0\ub7ec\n    ///\n    /// - Returns: \uc7ac\uc2dc\ub3c4 \uac00\ub2a5 \uc5ec\ubd80\n    ///\n    /// **\uc7ac\uc2dc\ub3c4 \uac00\ub2a5\ud55c \uc5d0\ub7ec:**\n    /// - \ub124\ud2b8\uc6cc\ud06c \uc5f0\uacb0 \uc2e4\ud328 (\uc77c\uc2dc\uc801)\n    /// - \ud0c0\uc784\uc544\uc6c3\n    /// - \uc11c\ubc84 \uc5d0\ub7ec (5xx)\n    /// - Rate limit (429)\n    ///\n    /// **\uc7ac\uc2dc\ub3c4 \ubd88\uac00\ub2a5\ud55c \uc5d0\ub7ec:**\n    /// - \uc778\uc99d \uc2e4\ud328 (401)\n    /// - \uc798\ubabb\ub41c \uc694\uccad (400)\n    /// - \ub9ac\uc18c\uc2a4 \uc5c6\uc74c (404)\n    /// - JSON \ud30c\uc2f1 \uc5d0\ub7ec\n    private func isRetryableError(_ error: Error) -> Bool {\n        // NetworkError \uccb4\ud06c\n        if let networkError = error as? NetworkError {\n            switch networkError {\n            case .timeout,\n                 .networkUnavailable:\n                return true // \uc7ac\uc2dc\ub3c4 \uac00\ub2a5\n\n            case .httpError(let statusCode, _):\n                // 5xx \uc11c\ubc84 \uc5d0\ub7ec\uc640 429 Rate Limit\ub294 \uc7ac\uc2dc\ub3c4 \uac00\ub2a5\n                return statusCode >= 500 || statusCode == 429\n\n            case .invalidURL,\n                 .noData,\n                 .decodingFailed,\n                 .invalidResponse,\n                 .unknown:\n                return false // \uc7ac\uc2dc\ub3c4 \ubd88\uac00\ub2a5\n            }\n        }\n\n        // \uae30\ud0c0 \uc5d0\ub7ec\ub294 \uc7ac\uc2dc\ub3c4 \uac00\ub2a5\ud558\ub2e4\uace0 \uac00\uc815 (\ubcf4\uc218\uc801 \uc811\uadfc)\n        return true\n    }\n\n    /// \uc5d0\ub7ec \ud0c0\uc785 \ubd84\ub958 (\ub85c\uae45\uc6a9)\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Error Classification\n    /// \uc5d0\ub7ec\ub97c \uc0ac\ub78c\uc774 \uc77d\uae30 \uc26c\uc6b4 \ud615\ud0dc\ub85c \ubd84\ub958\ud558\uc5ec \ub514\ubc84\uae45 \ud5a5\uc0c1\n    /// \ud83d\udca1 Java \ube44\uad50: Custom Exception \uacc4\uce35 \uad6c\uc870\uc640 \uc720\uc0ac\n    ///\n    /// - Parameter error: \ubc1c\uc0dd\ud55c \uc5d0\ub7ec\n    ///\n    /// - Returns: \uc5d0\ub7ec \ud0c0\uc785 \ubb38\uc790\uc5f4 (\ub85c\uae45\uc6a9)\n    private func classifyError(_ error: Error) -> String {\n        if let networkError = error as? NetworkError {\n            switch networkError {\n            case .timeout:\n                return \"TIMEOUT\"\n            case .networkUnavailable:\n                return \"OFFLINE\"\n            case .httpError(let statusCode, _):\n                if statusCode == 429 {\n                    return \"RATE_LIMIT\"\n                } else if statusCode >= 500 {\n                    return \"SERVER_ERROR\"\n                } else if statusCode == 401 || statusCode == 403 {\n                    return \"AUTH_ERROR\"\n                } else {\n                    return \"HTTP_ERROR_\\(statusCode)\"\n                }\n            case .decodingFailed:\n                return \"PARSING_ERROR\"\n            case .invalidURL:\n                return \"INVALID_URL\"\n            case .noData:\n                return \"NO_DATA\"\n            case .invalidResponse:\n                return \"INVALID_RESPONSE\"\n            case .unknown:\n                return \"UNKNOWN\"\n            }\n        }\n\n        // FoodSearchError \uccb4\ud06c\n        if let searchError = error as? FoodSearchError {\n            switch searchError {\n            case .invalidQuery:\n                return \"INVALID_QUERY\"\n            case .networkFailure:\n                return \"NETWORK_FAILURE\"\n            case .timeout:\n                return \"TIMEOUT\"\n            case .offline:\n                return \"OFFLINE\"\n            case .rateLimitExceeded:\n                return \"RATE_LIMIT\"\n            case .apiError:\n                return \"API_ERROR\"\n            case .kfdaApiError:\n                return \"KFDA_API_ERROR\"\n            case .usdaApiError:\n                return \"USDA_API_ERROR\"\n            case .authenticationFailed:\n                return \"AUTH_FAILED\"\n            case .parsingError:\n                return \"PARSING_ERROR\"\n            case .decodingFailed:\n                return \"DECODING_FAILED\"\n            case .cacheFailure:\n                return \"CACHE_ERROR\"\n            case .cacheUnavailable:\n                return \"CACHE_UNAVAILABLE\"\n            case .noResults:\n                return \"NO_RESULTS\"\n            case .insufficientData:\n                return \"INSUFFICIENT_DATA\"\n            case .unknown:\n                return \"UNKNOWN\"\n            }\n        }\n\n        // \uae30\ud0c0 \uc5d0\ub7ec\n        return \"UNKNOWN_ERROR\"\n    }\n\n    /// \uac80\uc0c9\uc5b4\uc5d0 \ud55c\uae00\uc774 \ud3ec\ud568\ub418\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Unicode Range Check\n    /// Swift\uc758 \uc720\ub2c8\ucf54\ub4dc \uc2a4\uce7c\ub77c\ub97c \uc0ac\uc6a9\ud558\uc5ec \ud55c\uae00 \ubb38\uc790 \ubc94\uc704 \ud655\uc778\n    /// \ud83d\udca1 Java \ube44\uad50: Character.UnicodeBlock.HANGUL_SYLLABLES\uc640 \uc720\uc0ac\n    ///\n    /// - Parameter text: \uac80\uc0c9\uc5b4\n    ///\n    /// - Returns: \ud55c\uae00 \ud3ec\ud568 \uc5ec\ubd80\n    ///\n    /// - Note: \ud55c\uae00 \uc74c\uc808 \ubc94\uc704: U+AC00 ~ U+D7A3 (\uac00 ~ \ud7a3)\n    private func containsKoreanCharacters(_ text: String) -> Bool {\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Unicode Scalar Value Check\n        // Swift String\uc740 \uc720\ub2c8\ucf54\ub4dc \uc2a4\uce7c\ub77c\ub85c \uad6c\uc131\ub418\uc5b4 \uc788\uc74c\n        // \ud55c\uae00 \uc74c\uc808 \ubc94\uc704\ub97c \uccb4\ud06c\ud558\uc5ec \ud55c\uae00 \uc5ec\ubd80 \ud310\ub2e8\n        // \ud83d\udca1 Java \ube44\uad50: text.matches(\".*[\\\\uAC00-\\\\uD7A3]+.*\")\uc640 \uc720\uc0ac\n\n        for scalar in text.unicodeScalars {\n            // \ud55c\uae00 \uc74c\uc808 \ubc94\uc704: U+AC00 (\uac00) ~ U+D7A3 (\ud7a3)\n            if (0xAC00...0xD7A3).contains(scalar.value) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    /// \uc911\ubcf5\ub41c \uc2dd\ud488 \uc81c\uac70\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Deduplication Strategy\n    /// apiCode\ub97c \uae30\uc900\uc73c\ub85c \uc911\ubcf5 \uc81c\uac70 (\uac19\uc740 \uc2dd\ud488\uc774 \uc5ec\ub7ec API\uc5d0\uc11c \ub098\uc62c \uc218 \uc788\uc74c)\n    /// \ud83d\udca1 Java \ube44\uad50: Stream.distinct() with custom comparator\n    ///\n    /// - Parameter foods: \uc2dd\ud488 \ubc30\uc5f4\n    ///\n    /// - Returns: \uc911\ubcf5 \uc81c\uac70\ub41c \uc2dd\ud488 \ubc30\uc5f4\n    ///\n    /// - Note: \uccab \ubc88\uc9f8\ub85c \ub098\uc628 \uc2dd\ud488\uc744 \uc720\uc9c0 (\uc21c\uc11c \ubcf4\uc874)\n    ///         apiCode\uac00 \uc5c6\ub294 \uc2dd\ud488\uc740 name\uc73c\ub85c \uc911\ubcf5 \uccb4\ud06c\n    private func deduplicateFoods(_ foods: [Food]) -> [Food] {\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Dictionary-based Deduplication\n        // \ub515\uc154\ub108\ub9ac\ub97c \uc0ac\uc6a9\ud558\uc5ec O(n) \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub85c \uc911\ubcf5 \uc81c\uac70\n        // \ud83d\udca1 Java \ube44\uad50: Map\uc744 \uc0ac\uc6a9\ud55c \uc911\ubcf5 \uc81c\uac70\uc640 \ub3d9\uc77c\n\n        var seen = Set<String>()\n        var result: [Food] = []\n\n        for food in foods {\n            // \uc911\ubcf5 \uccb4\ud06c \ud0a4: apiCode \uc6b0\uc120, \uc5c6\uc73c\uba74 name \uc0ac\uc6a9\n            let key = food.apiCode ?? food.name\n\n            // \uc774\ubbf8 \ubcf8 \uc801\uc774 \uc788\uc73c\uba74 \uc2a4\ud0b5\n            if seen.contains(key) {\n                continue\n            }\n\n            // \uc0c8\ub85c\uc6b4 \uc2dd\ud488\uc774\uba74 \ucd94\uac00\n            seen.insert(key)\n            result.append(food)\n        }\n\n        return result\n    }\n}\n\n// MARK: - Testing Support\n\n#if DEBUG\n/// \ud14c\uc2a4\ud2b8\uc6a9 Mock Unified Search Service\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Mock Objects for Testing\n/// \ud14c\uc2a4\ud2b8\uc5d0\uc11c \uc2e4\uc81c API \ud638\ucd9c \uc5c6\uc774 \ub3d9\uc791 \uac80\uc99d \uac00\ub2a5\n/// \ud83d\udca1 Java \ube44\uad50: Mockito\uc758 @Mock\uacfc \uc720\uc0ac\nfinal class MockUnifiedFoodSearchService {\n\n    /// Mock \uac80\uc0c9 \uacb0\uacfc\n    var mockSearchResults: [Food] = []\n\n    /// \uc5d0\ub7ec \uc2dc\ubbac\ub808\uc774\uc158\n    var shouldThrowError: Error?\n\n    /// \uac80\uc0c9 \uba54\uc11c\ub4dc Mock\n    func searchFoods(\n        query: String,\n        limit: Int = 20,\n        offset: Int = 0\n    ) async throws -> [Food] {\n\n        // \uc5d0\ub7ec \uc2dc\ubbac\ub808\uc774\uc158\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        // Mock \uacb0\uacfc \ubc18\ud658 (limit \uc801\uc6a9)\n        return Array(mockSearchResults.prefix(limit))\n    }\n}\n#endif\n",
        "last_modified": "2026-01-14T22:55:39.261854"
      },
      "task_intent": {
        "title": "005-korean-food-database-integration",
        "description": "Integrate Korean Food & Drug Administration (\uc2dd\uc57d\ucc98) food nutrition database API as primary source, with USDA FoodData Central as fallback for international foods. Prioritize Korean dishes (kimchi jjigae, bibimbap, tteokbokki) that are poorly covered by competitors.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T07:43:31.519122",
  "last_updated": "2026-01-13T07:46:24.243327"
}