{
  "file_path": "BodiiTests/Mappers/KFDAFoodMapperTests.swift",
  "main_branch_history": [],
  "task_views": {
    "005-korean-food-database-integration": {
      "task_id": "005-korean-food-database-integration",
      "branch_point": {
        "commit_hash": "c44bfbcd7c1699b176a8bb155e8c35f43ebd4ad9",
        "content": "",
        "timestamp": "2026-01-13T07:46:23.878686"
      },
      "worktree_state": {
        "content": "//\n//  KFDAFoodMapperTests.swift\n//  BodiiTests\n//\n//  Created by Auto-Claude on 2026-01-13.\n//\n\nimport XCTest\n@testable import Bodii\n\n/// Unit tests for KFDAFoodMapper DTO to Food entity mapping\n///\n/// KFDAFoodMapper\uc758 DTO \u2192 Food \uc5d4\ud2f0\ud2f0 \ub9e4\ud551 \ub2e8\uc704 \ud14c\uc2a4\ud2b8\nfinal class KFDAFoodMapperTests: XCTestCase {\n\n    // MARK: - Properties\n\n    var mapper: KFDAFoodMapper!\n\n    // MARK: - Setup & Teardown\n\n    override func setUp() {\n        super.setUp()\n        mapper = KFDAFoodMapper()\n    }\n\n    override func tearDown() {\n        mapper = nil\n        super.tearDown()\n    }\n\n    // MARK: - Successful Mapping Tests\n\n    /// Test: Valid KFDA DTO maps to Food entity successfully\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc720\ud6a8\ud55c KFDA DTO\uac00 Food \uc5d4\ud2f0\ud2f0\ub85c \uc131\uacf5\uc801\uc73c\ub85c \ubcc0\ud658\ub428\n    func testToDomain_ValidDTO_ReturnsFood() throws {\n        // Given: Valid KFDA DTO with all required fields\n        let dto = KFDAFoodDTO(\n            foodCd: \"D000001\",\n            descKor: \"\ud604\ubbf8\ubc25\",\n            groupCode: \"01\",\n            groupName: \"\uace1\ub958\",\n            enercKcal: \"330\",\n            prot: \"6.8\",\n            fat: \"2.5\",\n            chocdf: \"73.4\",\n            na: \"5\",\n            fibtg: \"3.0\",\n            sugar: \"0.5\",\n            servingSize: \"210\",\n            servingWt: \"200\",\n            servingUnit: \"1\uacf5\uae30\"\n        )\n\n        // When: Mapping to domain entity\n        let food = try mapper.toDomain(from: dto)\n\n        // Then: Should map all fields correctly\n        XCTAssertEqual(food.name, \"\ud604\ubbf8\ubc25\", \"Name should match\")\n        XCTAssertEqual(food.calories, 330, \"Calories should match\")\n        XCTAssertEqual(food.carbohydrates, Decimal(string: \"73.4\"), \"Carbohydrates should match\")\n        XCTAssertEqual(food.protein, Decimal(string: \"6.8\"), \"Protein should match\")\n        XCTAssertEqual(food.fat, Decimal(string: \"2.5\"), \"Fat should match\")\n        XCTAssertEqual(food.sodium, Decimal(5), \"Sodium should match\")\n        XCTAssertEqual(food.fiber, Decimal(3.0), \"Fiber should match\")\n        XCTAssertEqual(food.sugar, Decimal(0.5), \"Sugar should match\")\n        XCTAssertEqual(food.servingSize, Decimal(210), \"Serving size should match\")\n        XCTAssertEqual(food.servingUnit, \"1\uacf5\uae30\", \"Serving unit should match\")\n        XCTAssertEqual(food.source, .governmentAPI, \"Source should be governmentAPI\")\n        XCTAssertEqual(food.apiCode, \"D000001\", \"API code should match\")\n        XCTAssertNil(food.createdByUserId, \"createdByUserId should be nil for API data\")\n    }\n\n    /// Test: DTO with minimum required fields only\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ucd5c\uc18c \ud544\uc218 \ud544\ub4dc\ub9cc \uc788\ub294 DTO\n    func testToDomain_MinimumRequiredFields_ReturnsFood() throws {\n        // Given: DTO with only required fields (no optional fields)\n        let dto = KFDAFoodDTO(\n            foodCd: \"D000002\",\n            descKor: \"\uc300\ubc25\",\n            groupCode: nil,\n            groupName: nil,\n            enercKcal: \"300\",\n            prot: \"5.5\",\n            fat: \"1.2\",\n            chocdf: \"70.0\",\n            na: nil,\n            fibtg: nil,\n            sugar: nil,\n            servingSize: nil,\n            servingWt: nil,\n            servingUnit: nil\n        )\n\n        // When: Mapping to domain entity\n        let food = try mapper.toDomain(from: dto)\n\n        // Then: Should map required fields and use defaults for optional\n        XCTAssertEqual(food.name, \"\uc300\ubc25\", \"Name should match\")\n        XCTAssertEqual(food.calories, 300, \"Calories should match\")\n        XCTAssertEqual(food.carbohydrates, Decimal(70), \"Carbohydrates should match\")\n        XCTAssertEqual(food.protein, Decimal(5.5), \"Protein should match\")\n        XCTAssertEqual(food.fat, Decimal(1.2), \"Fat should match\")\n        XCTAssertNil(food.sodium, \"Sodium should be nil\")\n        XCTAssertNil(food.fiber, \"Fiber should be nil\")\n        XCTAssertNil(food.sugar, \"Sugar should be nil\")\n        XCTAssertEqual(food.servingSize, Decimal(100), \"Serving size should default to 100g\")\n        XCTAssertNil(food.servingUnit, \"Serving unit should be nil\")\n        XCTAssertEqual(food.source, .governmentAPI, \"Source should be governmentAPI\")\n        XCTAssertEqual(food.apiCode, \"D000002\", \"API code should match\")\n    }\n\n    /// Test: Name trimming (removes leading/trailing whitespace)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc774\ub984 \uacf5\ubc31 \uc81c\uac70 (\uc55e\ub4a4 \uacf5\ubc31 \uc81c\uac70\ub428)\n    func testToDomain_NameWithWhitespace_TrimsWhitespace() throws {\n        // Given: DTO with whitespace in name\n        let dto = KFDAFoodDTO(\n            foodCd: \"D000003\",\n            descKor: \"  \uae40\uce58\ucc0c\uac1c  \",\n            groupCode: nil,\n            groupName: nil,\n            enercKcal: \"150\",\n            prot: \"10.0\",\n            fat: \"8.0\",\n            chocdf: \"5.0\",\n            na: \"1000\",\n            fibtg: nil,\n            sugar: nil,\n            servingSize: \"250\",\n            servingWt: nil,\n            servingUnit: \"1\uc778\ubd84\"\n        )\n\n        // When: Mapping to domain entity\n        let food = try mapper.toDomain(from: dto)\n\n        // Then: Name should be trimmed\n        XCTAssertEqual(food.name, \"\uae40\uce58\ucc0c\uac1c\", \"Name should be trimmed\")\n    }\n\n    /// Test: Decimal calorie values are rounded correctly\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc18c\uc218\uc810 \uce7c\ub85c\ub9ac \uac12\uc774 \uc62c\ubc14\ub974\uac8c \ubc18\uc62c\ub9bc\ub428\n    func testToDomain_DecimalCalories_Rounded() throws {\n        // Given: DTOs with decimal calorie values\n        let testCases: [(calories: String, expected: Int32)] = [\n            (\"330.4\", 330),\n            (\"330.5\", 331),\n            (\"330.6\", 331),\n            (\"99.9\", 100)\n        ]\n\n        for testCase in testCases {\n            let dto = KFDAFoodDTO(\n                foodCd: \"D000004\",\n                descKor: \"Test Food\",\n                groupCode: nil,\n                groupName: nil,\n                enercKcal: testCase.calories,\n                prot: \"5.0\",\n                fat: \"2.0\",\n                chocdf: \"10.0\",\n                na: nil,\n                fibtg: nil,\n                sugar: nil,\n                servingSize: \"100\",\n                servingWt: nil,\n                servingUnit: nil\n            )\n\n            // When: Mapping to domain entity\n            let food = try mapper.toDomain(from: dto)\n\n            // Then: Calories should be rounded correctly\n            XCTAssertEqual(\n                food.calories,\n                testCase.expected,\n                \"Calories \\(testCase.calories) should round to \\(testCase.expected)\"\n            )\n        }\n    }\n\n    /// Test: Serving size fallback logic (servingSize \u2192 servingWt \u2192 100g default)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc81c\uacf5\ub7c9 \ud3f4\ubc31 \ub85c\uc9c1 (servingSize \u2192 servingWt \u2192 100g \uae30\ubcf8\uac12)\n    func testToDomain_ServingSizeFallback_UsesCorrectValue() throws {\n        // Given: DTOs with different serving size fields\n        let testCases: [(servingSize: String?, servingWt: String?, expected: Decimal)] = [\n            (\"210\", \"200\", 210),  // servingSize takes precedence\n            (nil, \"200\", 200),     // falls back to servingWt\n            (nil, nil, 100),       // defaults to 100g\n            (\"0\", \"200\", 200),     // servingSize=0 falls back to servingWt\n            (\"0\", \"0\", 100)        // both zero defaults to 100g\n        ]\n\n        for (index, testCase) in testCases.enumerated() {\n            let dto = KFDAFoodDTO(\n                foodCd: \"D\\(index)\",\n                descKor: \"Test Food \\(index)\",\n                groupCode: nil,\n                groupName: nil,\n                enercKcal: \"100\",\n                prot: \"5.0\",\n                fat: \"2.0\",\n                chocdf: \"10.0\",\n                na: nil,\n                fibtg: nil,\n                sugar: nil,\n                servingSize: testCase.servingSize,\n                servingWt: testCase.servingWt,\n                servingUnit: nil\n            )\n\n            // When: Mapping to domain entity\n            let food = try mapper.toDomain(from: dto)\n\n            // Then: Serving size should follow fallback logic\n            XCTAssertEqual(\n                food.servingSize,\n                testCase.expected,\n                \"Serving size should be \\(testCase.expected) for servingSize=\\(String(describing: testCase.servingSize)), servingWt=\\(String(describing: testCase.servingWt))\"\n            )\n        }\n    }\n\n    // MARK: - Error Cases Tests\n\n    /// Test: Missing foodCd throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: foodCd \ub204\ub77d \uc2dc \uc5d0\ub7ec \ubc1c\uc0dd\n    func testToDomain_MissingFoodCd_ThrowsError() {\n        // Given: DTO with empty foodCd\n        let dto = KFDAFoodDTO(\n            foodCd: \"\",\n            descKor: \"Test Food\",\n            groupCode: nil,\n            groupName: nil,\n            enercKcal: \"100\",\n            prot: \"5.0\",\n            fat: \"2.0\",\n            chocdf: \"10.0\",\n            na: nil,\n            fibtg: nil,\n            sugar: nil,\n            servingSize: \"100\",\n            servingWt: nil,\n            servingUnit: nil\n        )\n\n        // When/Then: Should throw missingRequiredField error\n        XCTAssertThrowsError(try mapper.toDomain(from: dto)) { error in\n            guard case MappingError.missingRequiredField(let field) = error else {\n                XCTFail(\"Expected MappingError.missingRequiredField, got \\(error)\")\n                return\n            }\n            XCTAssertEqual(field, \"foodCd\", \"Error should indicate missing foodCd\")\n        }\n    }\n\n    /// Test: Missing descKor throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: descKor \ub204\ub77d \uc2dc \uc5d0\ub7ec \ubc1c\uc0dd\n    func testToDomain_MissingDescKor_ThrowsError() {\n        // Given: DTO with empty descKor\n        let dto = KFDAFoodDTO(\n            foodCd: \"D000001\",\n            descKor: \"\",\n            groupCode: nil,\n            groupName: nil,\n            enercKcal: \"100\",\n            prot: \"5.0\",\n            fat: \"2.0\",\n            chocdf: \"10.0\",\n            na: nil,\n            fibtg: nil,\n            sugar: nil,\n            servingSize: \"100\",\n            servingWt: nil,\n            servingUnit: nil\n        )\n\n        // When/Then: Should throw missingRequiredField error\n        XCTAssertThrowsError(try mapper.toDomain(from: dto)) { error in\n            guard case MappingError.missingRequiredField(let field) = error else {\n                XCTFail(\"Expected MappingError.missingRequiredField, got \\(error)\")\n                return\n            }\n            XCTAssertEqual(field, \"descKor\", \"Error should indicate missing descKor\")\n        }\n    }\n\n    /// Test: Invalid calories throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc798\ubabb\ub41c \uce7c\ub85c\ub9ac \uac12 \uc2dc \uc5d0\ub7ec \ubc1c\uc0dd\n    func testToDomain_InvalidCalories_ThrowsError() {\n        // Given: DTOs with invalid calorie values\n        let invalidCalories = [nil, \"\", \"abc\", \"-100\"]\n\n        for invalidValue in invalidCalories {\n            let dto = KFDAFoodDTO(\n                foodCd: \"D000001\",\n                descKor: \"Test Food\",\n                groupCode: nil,\n                groupName: nil,\n                enercKcal: invalidValue,\n                prot: \"5.0\",\n                fat: \"2.0\",\n                chocdf: \"10.0\",\n                na: nil,\n                fibtg: nil,\n                sugar: nil,\n                servingSize: \"100\",\n                servingWt: nil,\n                servingUnit: nil\n            )\n\n            // When/Then: Should throw invalidNutritionData error\n            XCTAssertThrowsError(try mapper.toDomain(from: dto)) { error in\n                guard case MappingError.invalidNutritionData(let field) = error else {\n                    XCTFail(\"Expected MappingError.invalidNutritionData for calories=\\(String(describing: invalidValue)), got \\(error)\")\n                    return\n                }\n                XCTAssertEqual(field, \"enercKcal\", \"Error should indicate invalid enercKcal\")\n            }\n        }\n    }\n\n    /// Test: Invalid carbohydrates throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc798\ubabb\ub41c \ud0c4\uc218\ud654\ubb3c \uac12 \uc2dc \uc5d0\ub7ec \ubc1c\uc0dd\n    func testToDomain_InvalidCarbohydrates_ThrowsError() {\n        // Given: DTOs with invalid carbohydrate values\n        let invalidValues = [nil, \"\", \"abc\", \"-10\"]\n\n        for invalidValue in invalidValues {\n            let dto = KFDAFoodDTO(\n                foodCd: \"D000001\",\n                descKor: \"Test Food\",\n                groupCode: nil,\n                groupName: nil,\n                enercKcal: \"100\",\n                prot: \"5.0\",\n                fat: \"2.0\",\n                chocdf: invalidValue,\n                na: nil,\n                fibtg: nil,\n                sugar: nil,\n                servingSize: \"100\",\n                servingWt: nil,\n                servingUnit: nil\n            )\n\n            // When/Then: Should throw invalidNutritionData error\n            XCTAssertThrowsError(try mapper.toDomain(from: dto)) { error in\n                guard case MappingError.invalidNutritionData(let field) = error else {\n                    XCTFail(\"Expected MappingError.invalidNutritionData for chocdf=\\(String(describing: invalidValue)), got \\(error)\")\n                    return\n                }\n                XCTAssertEqual(field, \"chocdf\", \"Error should indicate invalid chocdf\")\n            }\n        }\n    }\n\n    /// Test: Invalid protein throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc798\ubabb\ub41c \ub2e8\ubc31\uc9c8 \uac12 \uc2dc \uc5d0\ub7ec \ubc1c\uc0dd\n    func testToDomain_InvalidProtein_ThrowsError() {\n        // Given: DTOs with invalid protein values\n        let invalidValues = [nil, \"\", \"abc\", \"-5\"]\n\n        for invalidValue in invalidValues {\n            let dto = KFDAFoodDTO(\n                foodCd: \"D000001\",\n                descKor: \"Test Food\",\n                groupCode: nil,\n                groupName: nil,\n                enercKcal: \"100\",\n                prot: invalidValue,\n                fat: \"2.0\",\n                chocdf: \"10.0\",\n                na: nil,\n                fibtg: nil,\n                sugar: nil,\n                servingSize: \"100\",\n                servingWt: nil,\n                servingUnit: nil\n            )\n\n            // When/Then: Should throw invalidNutritionData error\n            XCTAssertThrowsError(try mapper.toDomain(from: dto)) { error in\n                guard case MappingError.invalidNutritionData(let field) = error else {\n                    XCTFail(\"Expected MappingError.invalidNutritionData for prot=\\(String(describing: invalidValue)), got \\(error)\")\n                    return\n                }\n                XCTAssertEqual(field, \"prot\", \"Error should indicate invalid prot\")\n            }\n        }\n    }\n\n    /// Test: Invalid fat throws error\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc798\ubabb\ub41c \uc9c0\ubc29 \uac12 \uc2dc \uc5d0\ub7ec \ubc1c\uc0dd\n    func testToDomain_InvalidFat_ThrowsError() {\n        // Given: DTOs with invalid fat values\n        let invalidValues = [nil, \"\", \"abc\", \"-2\"]\n\n        for invalidValue in invalidValues {\n            let dto = KFDAFoodDTO(\n                foodCd: \"D000001\",\n                descKor: \"Test Food\",\n                groupCode: nil,\n                groupName: nil,\n                enercKcal: \"100\",\n                prot: \"5.0\",\n                fat: invalidValue,\n                chocdf: \"10.0\",\n                na: nil,\n                fibtg: nil,\n                sugar: nil,\n                servingSize: \"100\",\n                servingWt: nil,\n                servingUnit: nil\n            )\n\n            // When/Then: Should throw invalidNutritionData error\n            XCTAssertThrowsError(try mapper.toDomain(from: dto)) { error in\n                guard case MappingError.invalidNutritionData(let field) = error else {\n                    XCTFail(\"Expected MappingError.invalidNutritionData for fat=\\(String(describing: invalidValue)), got \\(error)\")\n                    return\n                }\n                XCTAssertEqual(field, \"fat\", \"Error should indicate invalid fat\")\n            }\n        }\n    }\n\n    // MARK: - Batch Mapping Tests\n\n    /// Test: Batch mapping with all valid DTOs\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ubaa8\ub450 \uc720\ud6a8\ud55c DTO\uc758 \ubc30\uce58 \ub9e4\ud551\n    func testToDomainArray_AllValid_ReturnsAllFoods() {\n        // Given: Array of valid DTOs\n        let dtos = [\n            createValidDTO(foodCd: \"D000001\", descKor: \"\ud604\ubbf8\ubc25\", calories: \"330\"),\n            createValidDTO(foodCd: \"D000002\", descKor: \"\uae40\uce58\ucc0c\uac1c\", calories: \"150\"),\n            createValidDTO(foodCd: \"D000003\", descKor: \"\ub41c\uc7a5\ucc0c\uac1c\", calories: \"120\")\n        ]\n\n        // When: Batch mapping to domain entities\n        let foods = mapper.toDomainArray(from: dtos)\n\n        // Then: All DTOs should be mapped\n        XCTAssertEqual(foods.count, 3, \"Should map all 3 DTOs\")\n        XCTAssertEqual(foods[0].name, \"\ud604\ubbf8\ubc25\", \"First food should be \ud604\ubbf8\ubc25\")\n        XCTAssertEqual(foods[1].name, \"\uae40\uce58\ucc0c\uac1c\", \"Second food should be \uae40\uce58\ucc0c\uac1c\")\n        XCTAssertEqual(foods[2].name, \"\ub41c\uc7a5\ucc0c\uac1c\", \"Third food should be \ub41c\uc7a5\ucc0c\uac1c\")\n    }\n\n    /// Test: Batch mapping with some invalid DTOs (filters out failures)\n    ///\n    /// \ud14c\uc2a4\ud2b8: \uc77c\ubd80 \ubb34\ud6a8\ud55c DTO\uc758 \ubc30\uce58 \ub9e4\ud551 (\uc2e4\ud328\ud55c \uac83\uc740 \uc81c\uc678\ub428)\n    func testToDomainArray_SomeInvalid_FiltersOutInvalid() {\n        // Given: Array with mix of valid and invalid DTOs\n        let dtos = [\n            createValidDTO(foodCd: \"D000001\", descKor: \"\ud604\ubbf8\ubc25\", calories: \"330\"),\n            createInvalidDTO(foodCd: \"\", descKor: \"Invalid\", calories: \"100\"), // Invalid: empty foodCd\n            createValidDTO(foodCd: \"D000003\", descKor: \"\uae40\uce58\ucc0c\uac1c\", calories: \"150\"),\n            createInvalidDTO(foodCd: \"D000004\", descKor: \"Invalid\", calories: nil), // Invalid: nil calories\n            createValidDTO(foodCd: \"D000005\", descKor: \"\ub41c\uc7a5\ucc0c\uac1c\", calories: \"120\")\n        ]\n\n        // When: Batch mapping to domain entities\n        let foods = mapper.toDomainArray(from: dtos)\n\n        // Then: Only valid DTOs should be mapped\n        XCTAssertEqual(foods.count, 3, \"Should map only 3 valid DTOs\")\n        XCTAssertEqual(foods[0].name, \"\ud604\ubbf8\ubc25\", \"First food should be \ud604\ubbf8\ubc25\")\n        XCTAssertEqual(foods[1].name, \"\uae40\uce58\ucc0c\uac1c\", \"Second food should be \uae40\uce58\ucc0c\uac1c\")\n        XCTAssertEqual(foods[2].name, \"\ub41c\uc7a5\ucc0c\uac1c\", \"Third food should be \ub41c\uc7a5\ucc0c\uac1c\")\n    }\n\n    /// Test: Batch mapping with all invalid DTOs returns empty array\n    ///\n    /// \ud14c\uc2a4\ud2b8: \ubaa8\ub450 \ubb34\ud6a8\ud55c DTO\uc758 \ubc30\uce58 \ub9e4\ud551 \uc2dc \ube48 \ubc30\uc5f4 \ubc18\ud658\n    func testToDomainArray_AllInvalid_ReturnsEmptyArray() {\n        // Given: Array of all invalid DTOs\n        let dtos = [\n            createInvalidDTO(foodCd: \"\", descKor: \"Invalid 1\", calories: \"100\"),\n            createInvalidDTO(foodCd: \"D000002\", descKor: \"\", calories: \"100\"),\n            createInvalidDTO(foodCd: \"D000003\", descKor: \"Invalid 3\", calories: nil)\n        ]\n\n        // When: Batch mapping to domain entities\n        let foods = mapper.toDomainArray(from: dtos)\n\n        // Then: Should return empty array\n        XCTAssertEqual(foods.count, 0, \"Should return empty array for all invalid DTOs\")\n    }\n\n    // MARK: - Helper Methods\n\n    /// Create a valid DTO for testing\n    private func createValidDTO(\n        foodCd: String,\n        descKor: String,\n        calories: String\n    ) -> KFDAFoodDTO {\n        return KFDAFoodDTO(\n            foodCd: foodCd,\n            descKor: descKor,\n            groupCode: \"01\",\n            groupName: \"\uace1\ub958\",\n            enercKcal: calories,\n            prot: \"5.0\",\n            fat: \"2.0\",\n            chocdf: \"10.0\",\n            na: \"5\",\n            fibtg: \"1.0\",\n            sugar: \"0.5\",\n            servingSize: \"100\",\n            servingWt: \"100\",\n            servingUnit: \"1\uc778\ubd84\"\n        )\n    }\n\n    /// Create an invalid DTO for testing\n    private func createInvalidDTO(\n        foodCd: String,\n        descKor: String,\n        calories: String?\n    ) -> KFDAFoodDTO {\n        return KFDAFoodDTO(\n            foodCd: foodCd,\n            descKor: descKor,\n            groupCode: nil,\n            groupName: nil,\n            enercKcal: calories,\n            prot: \"5.0\",\n            fat: \"2.0\",\n            chocdf: \"10.0\",\n            na: nil,\n            fibtg: nil,\n            sugar: nil,\n            servingSize: \"100\",\n            servingWt: nil,\n            servingUnit: nil\n        )\n    }\n}\n",
        "last_modified": "2026-01-14T22:55:39.268839"
      },
      "task_intent": {
        "title": "005-korean-food-database-integration",
        "description": "Integrate Korean Food & Drug Administration (\uc2dd\uc57d\ucc98) food nutrition database API as primary source, with USDA FoodData Central as fallback for international foods. Prioritize Korean dishes (kimchi jjigae, bibimbap, tteokbokki) that are poorly covered by competitors.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T07:43:31.788285",
  "last_updated": "2026-01-13T07:46:23.889755"
}