{
  "file_path": "Bodii/Data/Repositories/FoodSearchRepositoryImpl.swift",
  "main_branch_history": [],
  "task_views": {
    "005-korean-food-database-integration": {
      "task_id": "005-korean-food-database-integration",
      "branch_point": {
        "commit_hash": "c44bfbcd7c1699b176a8bb155e8c35f43ebd4ad9",
        "content": "",
        "timestamp": "2026-01-13T07:46:23.878686"
      },
      "worktree_state": {
        "content": "//\n//  FoodSearchRepositoryImpl.swift\n//  Bodii\n//\n//  Created by Auto-Claude on 2026-01-13.\n//\n\n// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Repository Implementation\n// Repository \ud328\ud134\uc758 \uad6c\ud604\uccb4\ub85c, \ub3c4\uba54\uc778 \ub808\uc774\uc5b4\uc758 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc2e4\uc81c\ub85c \uad6c\ud604\n// \ud83d\udca1 Java \ube44\uad50: JpaRepository \uad6c\ud604\uccb4 (Spring Data)\uc640 \uc720\uc0ac\n\nimport Foundation\n\n/// \uc2dd\ud488 \uac80\uc0c9 \uc800\uc7a5\uc18c \uad6c\ud604\uccb4\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Repository Pattern Implementation\n/// FoodSearchRepository \ud504\ub85c\ud1a0\ucf5c\uc744 \uad6c\ud604\ud558\uc5ec \ub370\uc774\ud130 \uc18c\uc2a4 \ucd94\uc0c1\ud654\n/// \uc5ec\ub7ec \ub370\uc774\ud130 \uc18c\uc2a4(\uc2dd\uc57d\ucc98 API, USDA API, \ub85c\uceec \uce90\uc2dc)\ub97c \ud1b5\ud569\ud558\uc5ec \ub2e8\uc77c \uc778\ud130\ud398\uc774\uc2a4 \uc81c\uacf5\n/// \ud83d\udca1 Java \ube44\uad50: Repository \uc778\ud130\ud398\uc774\uc2a4\uc758 \uad6c\ud604\uccb4 (\uc608: UserRepositoryImpl)\n///\n/// **\uc544\ud0a4\ud14d\ucc98:**\n/// ```\n/// ViewModel/UseCase\n///        \u2193\n/// FoodSearchRepository (Protocol) \u2190 Domain Layer\n///        \u2193\n/// FoodSearchRepositoryImpl (Implementation) \u2190 Data Layer\n///        \u2193\n/// UnifiedFoodSearchService \u2192 KFDA/USDA APIs\n///        \u2193\n/// FoodLocalDataSource \u2192 Core Data\n/// ```\n///\n/// **\uc5ed\ud560:**\n/// - \ud504\ub85c\ud1a0\ucf5c\uc5d0 \uc815\uc758\ub41c \uba54\uc11c\ub4dc\ub97c \uc2e4\uc81c\ub85c \uad6c\ud604\n/// - UnifiedFoodSearchService\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub2e4\uc911 API \uac80\uc0c9\n/// - \ub85c\uceec \uce90\uc2dc \uad00\ub9ac (\ucd5c\uadfc \uac80\uc0c9, \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8, \uce90\uc2dc \uc815\ub9ac)\n/// - \ube44\uc988\ub2c8\uc2a4 \ub85c\uc9c1\uacfc \ub370\uc774\ud130 \uc18c\uc2a4 \ubd84\ub9ac\n///\n/// **\ud2b9\uc9d5:**\n/// - \uc758\uc874\uc131 \uc8fc\uc785\uc744 \ud1b5\ud55c \ud14c\uc2a4\ud2b8 \uc6a9\uc774\uc131\n/// - Graceful degradation (\ud55c API \uc2e4\ud328 \uc2dc \ub2e4\ub978 API \ud65c\uc6a9)\n/// - \uc624\ud504\ub77c\uc778 \uc9c0\uc6d0 (\uce90\uc2dc \ud65c\uc6a9)\n/// - \uacb0\uacfc \uc911\ubcf5 \uc81c\uac70\n///\n/// **\uc0ac\uc6a9 \uc608\uc2dc:**\n/// ```swift\n/// // DIContainer\uc5d0\uc11c \uc8fc\uc785\ubc1b\uc74c\n/// let repository: FoodSearchRepository = FoodSearchRepositoryImpl(\n///     searchService: UnifiedFoodSearchService(),\n///     localDataSource: FoodLocalDataSource()\n/// )\n///\n/// // \uc2dd\ud488 \uac80\uc0c9\n/// let foods = try await repository.searchFoods(query: \"\uae40\uce58\ucc0c\uac1c\", limit: 20)\n///\n/// // \ucd5c\uadfc \uac80\uc0c9 \uc2dd\ud488\n/// let recentFoods = try await repository.getRecentFoods(limit: 10)\n/// ```\nfinal class FoodSearchRepositoryImpl: FoodSearchRepository {\n\n    // MARK: - Properties\n\n    /// \ud1b5\ud569 \uc2dd\ud488 \uac80\uc0c9 \uc11c\ube44\uc2a4\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Dependency Injection\n    /// \uc678\ubd80\uc5d0\uc11c \uc8fc\uc785\ubc1b\uc544 \ud14c\uc2a4\ud2b8 \uc2dc Mock\uc73c\ub85c \uad50\uccb4 \uac00\ub2a5\n    /// \ud83d\udca1 Java \ube44\uad50: @Autowired field injection\n    private let searchService: UnifiedFoodSearchService\n\n    /// \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4 (\uce90\uc2dc)\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Optional Dependency\n    /// \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4\uac00 \uad6c\ud604\ub418\uae30 \uc804\uae4c\uc9c0\ub294 nil\ub85c \ub3d9\uc791\n    /// Phase 5\uc5d0\uc11c \uad6c\ud604 \ud6c4 \uc8fc\uc785\ubc1b\uc744 \uc608\uc815\n    /// \ud83d\udca1 Java \ube44\uad50: @Autowired(required = false)\uc640 \uc720\uc0ac\n    private let localDataSource: FoodLocalDataSource?\n\n    // MARK: - Initialization\n\n    /// FoodSearchRepositoryImpl \ucd08\uae30\ud654\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Constructor Injection\n    /// \ubaa8\ub4e0 \uc758\uc874\uc131\uc744 \uc0dd\uc131\uc790\ub97c \ud1b5\ud574 \uc8fc\uc785\ubc1b\uc544 \ud14c\uc2a4\ud2b8 \uc6a9\uc774\uc131 \ud5a5\uc0c1\n    /// \ud83d\udca1 Java \ube44\uad50: @Inject constructor\uc640 \uc720\uc0ac\n    ///\n    /// - Parameters:\n    ///   - searchService: \ud1b5\ud569 \uac80\uc0c9 \uc11c\ube44\uc2a4 (\uae30\ubcf8\uac12: UnifiedFoodSearchService())\n    ///   - localDataSource: \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4 (\uae30\ubcf8\uac12: nil, Phase 5\uc5d0\uc11c \uad6c\ud604 \uc608\uc815)\n    init(\n        searchService: UnifiedFoodSearchService = UnifiedFoodSearchService(),\n        localDataSource: FoodLocalDataSource? = nil\n    ) {\n        self.searchService = searchService\n        self.localDataSource = localDataSource\n    }\n\n    // MARK: - FoodSearchRepository Protocol Implementation\n\n    /// \uc2dd\ud488 \uac80\uc0c9\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Multi-Source Search Strategy\n    /// 1. \uce90\uc2dc \ud655\uc778 (useCache=true\uc778 \uacbd\uc6b0)\n    /// 2. UnifiedFoodSearchService\ub97c \ud1b5\ud55c API \uac80\uc0c9\n    /// 3. \uac80\uc0c9 \uacb0\uacfc\ub97c \uce90\uc2dc\uc5d0 \uc800\uc7a5\n    /// \ud83d\udca1 Java \ube44\uad50: @Cacheable \uc5b4\ub178\ud14c\uc774\uc158\uc744 \uc0ac\uc6a9\ud55c \uce90\uc2f1 \ub85c\uc9c1\uacfc \uc720\uc0ac\n    ///\n    /// - Parameters:\n    ///   - query: \uac80\uc0c9\uc5b4 (\uc2dd\ud488\uba85)\n    ///   - limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218\n    ///   - offset: \ud398\uc774\uc9d5 \uc624\ud504\uc14b (\ud604\uc7ac \ubc84\uc804\uc5d0\uc11c\ub294 \ubbf8\uc9c0\uc6d0)\n    ///   - useCache: \uce90\uc2dc \uc0ac\uc6a9 \uc5ec\ubd80\n    ///\n    /// - Returns: \uac80\uc0c9\ub41c \uc2dd\ud488 \ubc30\uc5f4\n    ///\n    /// - Throws:\n    ///   - `FoodSearchError.invalidQuery`: \uac80\uc0c9\uc5b4\uac00 \ube44\uc5b4\uc788\uac70\ub098 \uc720\ud6a8\ud558\uc9c0 \uc54a\uc74c\n    ///   - `FoodSearchError.networkFailure`: \ub124\ud2b8\uc6cc\ud06c \uc5f0\uacb0 \uc2e4\ud328\n    ///   - `FoodSearchError.apiError`: API \uc694\uccad \uc2e4\ud328\n    ///   - `FoodSearchError.noResults`: \uac80\uc0c9 \uacb0\uacfc \uc5c6\uc74c\n    func searchFoods(\n        query: String,\n        limit: Int,\n        offset: Int,\n        useCache: Bool\n    ) async throws -> [Food] {\n\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Input Validation\n        // \uac80\uc0c9\uc5b4 \uc720\ud6a8\uc131 \uac80\uc99d\uc744 \ub3c4\uba54\uc778 \ub808\uc774\uc5b4\uc5d0\uc11c \uc218\ud589\n        // \ud83d\udca1 Java \ube44\uad50: @Valid \uc5b4\ub178\ud14c\uc774\uc158\uacfc \uc720\uc0ac\ud55c \uc5ed\ud560\n        guard !query.trimmingCharacters(in: .whitespaces).isEmpty else {\n            throw FoodSearchError.invalidQuery(\"\uac80\uc0c9\uc5b4\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694.\")\n        }\n\n        guard limit > 0 else {\n            throw FoodSearchError.invalidQuery(\"limit\uc740 1 \uc774\uc0c1\uc774\uc5b4\uc57c \ud569\ub2c8\ub2e4.\")\n        }\n\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Cache-First Strategy (Phase 5\uc5d0\uc11c \uad6c\ud604 \uc608\uc815)\n        // useCache\uac00 true\uc774\uace0 \uce90\uc2dc\uc5d0 \uacb0\uacfc\uac00 \uc788\uc73c\uba74 \uce90\uc2dc \ubc18\ud658\n        // \ud83d\udca1 Java \ube44\uad50: Spring Cache\uc758 @Cacheable\uacfc \uc720\uc0ac\n        if useCache, let localDataSource = localDataSource {\n            do {\n                // \uce90\uc2dc\uc5d0\uc11c \uac80\uc0c9 (\uc815\ud655\ud55c \ub9e4\uce6d)\n                let cachedFoods = try await localDataSource.searchFoods(\n                    query: query,\n                    limit: limit\n                )\n\n                // \uce90\uc2dc\uc5d0 \ucda9\ubd84\ud55c \uacb0\uacfc\uac00 \uc788\uc73c\uba74 \ubc18\ud658\n                if !cachedFoods.isEmpty {\n                    #if DEBUG\n                    print(\"\u2705 Cache hit: \\(cachedFoods.count) foods found for '\\(query)'\")\n                    #endif\n                    return cachedFoods\n                }\n            } catch {\n                // \uce90\uc2dc \uc870\ud68c \uc2e4\ud328\ub294 \ubb34\uc2dc\ud558\uace0 API \uac80\uc0c9 \uc9c4\ud589\n                #if DEBUG\n                print(\"\u26a0\ufe0f Cache lookup failed: \\(error.localizedDescription)\")\n                #endif\n            }\n        }\n\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: API Search with Error Handling\n        // UnifiedFoodSearchService\ub97c \ud1b5\ud574 \ub2e4\uc911 API \uac80\uc0c9\n        // \ud83d\udca1 Java \ube44\uad50: RestTemplate\uc744 \uc0ac\uc6a9\ud55c API \ud638\ucd9c\uacfc \uc720\uc0ac\n        do {\n            let foods = try await searchService.searchFoods(\n                query: query,\n                limit: limit,\n                offset: offset\n            )\n\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Async Cache Update\n            // \uac80\uc0c9 \uacb0\uacfc\ub97c \ubc31\uadf8\ub77c\uc6b4\ub4dc\uc5d0\uc11c \uce90\uc2dc\uc5d0 \uc800\uc7a5\n            // \ud83d\udca1 Java \ube44\uad50: @CachePut \uc5b4\ub178\ud14c\uc774\uc158\uacfc \uc720\uc0ac\n            if let localDataSource = localDataSource {\n                Task {\n                    do {\n                        try await localDataSource.saveFoods(foods)\n                        #if DEBUG\n                        print(\"\u2705 Cached \\(foods.count) foods for query '\\(query)'\")\n                        #endif\n                    } catch {\n                        // \uce90\uc2dc \uc800\uc7a5 \uc2e4\ud328\ub294 \ub85c\uae45\ub9cc \ud558\uace0 \ubb34\uc2dc\n                        #if DEBUG\n                        print(\"\u26a0\ufe0f Failed to cache foods: \\(error.localizedDescription)\")\n                        #endif\n                    }\n                }\n            }\n\n            // \uacb0\uacfc\uac00 \uc5c6\uc73c\uba74 noResults \uc5d0\ub7ec \ub358\uc9c0\uae30 (\uc120\ud0dd\uc801)\n            // \ud604\uc7ac\ub294 \ube48 \ubc30\uc5f4\uc744 \ubc18\ud658\ud558\ub294 \uac83\uc774 \ub354 \ub098\uc740 UX\n            if foods.isEmpty {\n                #if DEBUG\n                print(\"\u2139\ufe0f No results found for '\\(query)'\")\n                #endif\n            }\n\n            return foods\n\n        } catch {\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Offline Fallback Strategy\n            // API \uc2e4\ud328 \uc2dc \uce90\uc2dc\uc5d0\uc11c \uac80\uc0c9\ud558\uc5ec \uc624\ud504\ub77c\uc778 \uc9c0\uc6d0\n            // \ud83d\udca1 Java \ube44\uad50: Circuit Breaker + Cache Fallback \ud328\ud134\uacfc \uc720\uc0ac\n\n            #if DEBUG\n            print(\"\u26a0\ufe0f API search failed: \\(error.localizedDescription)\")\n            #endif\n\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Graceful Degradation\n            // \ub124\ud2b8\uc6cc\ud06c \uc2e4\ud328 \uc2dc \uce90\uc2dc\uc5d0\uc11c \uacb0\uacfc \ubc18\ud658\ud558\uc5ec \uc624\ud504\ub77c\uc778 \uc9c0\uc6d0\n            if let localDataSource = localDataSource {\n                do {\n                    let cachedFoods = try await localDataSource.searchFoods(\n                        query: query,\n                        limit: limit\n                    )\n\n                    if !cachedFoods.isEmpty {\n                        #if DEBUG\n                        print(\"\u2705 Offline fallback: Returned \\(cachedFoods.count) cached foods\")\n                        #endif\n                        return cachedFoods\n                    }\n\n                    #if DEBUG\n                    print(\"\u2139\ufe0f No cached results found for '\\(query)'\")\n                    #endif\n\n                } catch {\n                    #if DEBUG\n                    print(\"\u26a0\ufe0f Cache fallback also failed: \\(error.localizedDescription)\")\n                    #endif\n                }\n            }\n\n            // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Error Mapping\n            // \ud558\uc704 \ub808\uc774\uc5b4\uc758 \uc5d0\ub7ec\ub97c \ub3c4\uba54\uc778 \uc5d0\ub7ec\ub85c \ubcc0\ud658\n            // \ud83d\udca1 Java \ube44\uad50: Custom Exception Translator\uc640 \uc720\uc0ac\n\n            // \uc774\ubbf8 FoodSearchError\uc778 \uacbd\uc6b0 \uadf8\ub300\ub85c \uc804\ud30c\n            if let foodSearchError = error as? FoodSearchError {\n                throw foodSearchError\n            }\n\n            // \uae30\ud0c0 \uc5d0\ub7ec\ub294 unknown\uc73c\ub85c \ub798\ud551\n            throw FoodSearchError.unknown(error)\n        }\n    }\n\n    /// \ucd5c\uadfc \uac80\uc0c9\ud55c \uc2dd\ud488 \ubaa9\ub85d \uc870\ud68c\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Cache-Only Query\n    /// \ub85c\uceec \uce90\uc2dc\uc5d0\uc11c\ub9cc \ub370\uc774\ud130\ub97c \uac00\uc838\uc634 (API \ud638\ucd9c \uc5c6\uc74c)\n    /// \ud83d\udca1 Java \ube44\uad50: Cache\uc5d0\uc11c\ub9cc \uc870\ud68c\ud558\ub294 findAllFromCache()\uc640 \uc720\uc0ac\n    ///\n    /// - Parameter limit: \ucd5c\ub300 \uacb0\uacfc \uac1c\uc218\n    ///\n    /// - Returns: \ucd5c\uadfc \uac80\uc0c9\ud55c \uc2dd\ud488 \ubaa9\ub85d (lastAccessedAt \uae30\uc900 \uc815\ub82c)\n    ///\n    /// - Throws: `FoodSearchError.cacheFailure`: \uce90\uc2dc \uc870\ud68c \uc2e4\ud328\n    func getRecentFoods(limit: Int) async throws -> [Food] {\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Optional Chaining with Throw\n        // localDataSource\uac00 nil\uc774\uba74 \ube48 \ubc30\uc5f4 \ubc18\ud658\n        // \ud83d\udca1 Java \ube44\uad50: Optional.orElse(Collections.emptyList())\uc640 \uc720\uc0ac\n        guard let localDataSource = localDataSource else {\n            #if DEBUG\n            print(\"\u2139\ufe0f Local data source not available, returning empty array\")\n            #endif\n            return []\n        }\n\n        do {\n            let recentFoods = try await localDataSource.getRecentFoods(limit: limit)\n\n            #if DEBUG\n            print(\"\u2705 Retrieved \\(recentFoods.count) recent foods\")\n            #endif\n\n            return recentFoods\n\n        } catch {\n            // \uce90\uc2dc \uc5d0\ub7ec\ub97c \ub3c4\uba54\uc778 \uc5d0\ub7ec\ub85c \ubcc0\ud658\n            throw FoodSearchError.cacheFailure(error)\n        }\n    }\n\n    /// \uc2dd\ud488 \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Activity Tracking\n    /// \uc0ac\uc6a9\uc790\uac00 \uc2dd\ud488\uc744 \uc120\ud0dd\ud560 \ub54c\ub9c8\ub2e4 \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8\n    /// LRU(Least Recently Used) \uce90\uc2dc \uc815\ucc45\uc5d0 \uc0ac\uc6a9\n    /// \ud83d\udca1 Java \ube44\uad50: @CachePut with timestamp update\n    ///\n    /// - Parameter foodId: \uc2dd\ud488 \uace0\uc720 ID\n    ///\n    /// - Throws: `FoodSearchError.cacheFailure`: \uce90\uc2dc \uc5c5\ub370\uc774\ud2b8 \uc2e4\ud328\n    func updateFoodAccessTime(foodId: UUID) async throws {\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Early Return Pattern\n        // localDataSource\uac00 \uc5c6\uc73c\uba74 \uc870\uc6a9\ud788 \ub9ac\ud134\n        // \ud83d\udca1 Java \ube44\uad50: Optional.ifPresent()\uc640 \uc720\uc0ac\n        guard let localDataSource = localDataSource else {\n            #if DEBUG\n            print(\"\u2139\ufe0f Local data source not available, skipping access time update\")\n            #endif\n            return\n        }\n\n        do {\n            try await localDataSource.updateAccessTime(foodId: foodId)\n\n            #if DEBUG\n            print(\"\u2705 Updated access time for food: \\(foodId)\")\n            #endif\n\n        } catch {\n            // \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8 \uc2e4\ud328\ub294 \uce58\uba85\uc801\uc774\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub85c\uae45\ub9cc\n            #if DEBUG\n            print(\"\u26a0\ufe0f Failed to update access time: \\(error.localizedDescription)\")\n            #endif\n\n            // \uc5d0\ub7ec\ub97c \ub358\uc9c0\uc9c0 \uc54a\uace0 \ubb34\uc2dc (UX\uc5d0 \uc601\ud5a5 \uc5c6\uc74c)\n            // \ud544\uc694\ud558\ub2e4\uba74 \uc5ec\uae30\uc11c throw \uac00\ub2a5\n        }\n    }\n\n    /// \uce90\uc2dc \uc815\ub9ac (LRU \uc815\ucc45)\n    ///\n    /// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Cache Eviction Policy\n    /// \uc624\ub798\ub41c \uce90\uc2dc \ud56d\ubaa9\uc744 \uc790\ub3d9\uc73c\ub85c \uc815\ub9ac\ud558\uc5ec \uc800\uc7a5 \uacf5\uac04 \ucd5c\uc801\ud654\n    /// \ud83d\udca1 Java \ube44\uad50: @CacheEvict(allEntries=true)\uc640 \uc720\uc0ac\n    ///\n    /// - Parameter maxCacheSize: \uce90\uc2dc \ucd5c\ub300 \ud06c\uae30\n    ///\n    /// - Throws: `FoodSearchError.cacheFailure`: \uce90\uc2dc \uc815\ub9ac \uc2e4\ud328\n    func cleanupCache(maxCacheSize: Int) async throws {\n        // \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Early Return Pattern\n        // localDataSource\uac00 \uc5c6\uc73c\uba74 \uc870\uc6a9\ud788 \ub9ac\ud134\n        guard let localDataSource = localDataSource else {\n            #if DEBUG\n            print(\"\u2139\ufe0f Local data source not available, skipping cache cleanup\")\n            #endif\n            return\n        }\n\n        do {\n            try await localDataSource.cleanupOldFoods(maxCount: maxCacheSize)\n\n            #if DEBUG\n            print(\"\u2705 Cache cleanup completed (max: \\(maxCacheSize))\")\n            #endif\n\n        } catch {\n            // \uce90\uc2dc \uc815\ub9ac \uc2e4\ud328\ub97c \ub3c4\uba54\uc778 \uc5d0\ub7ec\ub85c \ubcc0\ud658\n            throw FoodSearchError.cacheFailure(error)\n        }\n    }\n}\n\n// MARK: - FoodLocalDataSource Protocol\n\n/// \uc2dd\ud488 \ub85c\uceec \ub370\uc774\ud130 \uc18c\uc2a4 \ud504\ub85c\ud1a0\ucf5c\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Data Source Protocol\n/// Core Data\ub97c \uc0ac\uc6a9\ud55c \ub85c\uceec \uce90\uc2f1 \uc778\ud130\ud398\uc774\uc2a4\n/// \ud83d\udca1 Java \ube44\uad50: DAO (Data Access Object) \uc778\ud130\ud398\uc774\uc2a4\uc640 \uc720\uc0ac\n///\n/// - Note: \uc2e4\uc81c \uad6c\ud604\uc740 FoodLocalDataSourceImpl (Phase 5.2)\nprotocol FoodLocalDataSource {\n    /// \uc2dd\ud488 \uac80\uc0c9 (\ub85c\uceec \uce90\uc2dc)\n    func searchFoods(query: String, limit: Int) async throws -> [Food]\n\n    /// \ucd5c\uadfc \uac80\uc0c9\ud55c \uc2dd\ud488 \uc870\ud68c\n    func getRecentFoods(limit: Int) async throws -> [Food]\n\n    /// \uc2dd\ud488 \uc800\uc7a5 (\uce90\uc2dc)\n    func saveFoods(_ foods: [Food]) async throws\n\n    /// \uc811\uadfc \uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8\n    func updateAccessTime(foodId: UUID) async throws\n\n    /// \uc624\ub798\ub41c \uce90\uc2dc \uc815\ub9ac\n    func cleanupOldFoods(maxCount: Int) async throws\n}\n\n// MARK: - Testing Support\n\n#if DEBUG\n/// \ud14c\uc2a4\ud2b8\uc6a9 Mock FoodSearchRepository\n///\n/// \ud83d\udcda \ud559\uc2b5 \ud3ec\uc778\ud2b8: Mock Repository for Testing\n/// \ud14c\uc2a4\ud2b8\uc5d0\uc11c \uc2e4\uc81c API/DB \uc5c6\uc774 \ub3d9\uc791 \uac80\uc99d \uac00\ub2a5\n/// \ud83d\udca1 Java \ube44\uad50: Mockito\uc758 @Mock \ub610\ub294 @InjectMocks\uc640 \uc720\uc0ac\nfinal class MockFoodSearchRepository: FoodSearchRepository {\n\n    /// Mock \uac80\uc0c9 \uacb0\uacfc\n    var mockSearchResults: [Food] = []\n\n    /// Mock \ucd5c\uadfc \uc2dd\ud488\n    var mockRecentFoods: [Food] = []\n\n    /// \uc5d0\ub7ec \uc2dc\ubbac\ub808\uc774\uc158\n    var shouldThrowError: Error?\n\n    /// \ud638\ucd9c \ucd94\uc801\n    var searchCallCount = 0\n    var getRecentCallCount = 0\n    var updateAccessTimeCallCount = 0\n    var cleanupCacheCallCount = 0\n\n    func searchFoods(\n        query: String,\n        limit: Int,\n        offset: Int,\n        useCache: Bool\n    ) async throws -> [Food] {\n        searchCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        return Array(mockSearchResults.prefix(limit))\n    }\n\n    func getRecentFoods(limit: Int) async throws -> [Food] {\n        getRecentCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n\n        return Array(mockRecentFoods.prefix(limit))\n    }\n\n    func updateFoodAccessTime(foodId: UUID) async throws {\n        updateAccessTimeCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n    }\n\n    func cleanupCache(maxCacheSize: Int) async throws {\n        cleanupCacheCallCount += 1\n\n        if let error = shouldThrowError {\n            throw error\n        }\n    }\n}\n#endif\n",
        "last_modified": "2026-01-14T22:55:39.263469"
      },
      "task_intent": {
        "title": "005-korean-food-database-integration",
        "description": "Integrate Korean Food & Drug Administration (\uc2dd\uc57d\ucc98) food nutrition database API as primary source, with USDA FoodData Central as fallback for international foods. Prioritize Korean dishes (kimchi jjigae, bibimbap, tteokbokki) that are poorly covered by competitors.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T07:43:31.507638",
  "last_updated": "2026-01-13T07:46:24.068941"
}