# Build Progress - 002 Project Foundation & Core Data Model

## Subtask 3.9: Create Goal Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/Goal.swift
**Commit:** 4f3229d

### Implementation Details

All acceptance criteria have been met:

✅ **Goal struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **Target values:**
   - targetWeight: Decimal (목표 체중, kg, 20-300kg range)
   - targetBodyFatPct: Decimal (목표 체지방률, %, 3-60% range)
   - targetMuscleMass: Decimal (목표 근육량, kg, 10-60kg range)

✅ **Weekly change rates:**
   - weeklyWeightRate: Decimal (주간 체중 변화율, kg/week)
   - weeklyFatPctRate: Decimal (주간 체지방률 변화율, %/week)
   - weeklyMuscleRate: Decimal (주간 근육량 변화율, kg/week)

✅ **Start values (snapshots):**
   - startWeight: Decimal (시작 체중)
   - startBodyFatPct: Decimal (시작 체지방률)
   - startMuscleMass: Decimal (시작 근육량)
   - startBMR: Int (시작 기초대사량)
   - startTDEE: Int (시작 일일 총 에너지 소비량)

✅ **Additional properties:**
   - goalType: GoalType enum (lose/maintain/gain)
   - dailyCalorieTarget: Int (일일 칼로리 목표)
   - isActive: Bool (목표 활성화 여부)
   - startDate: Date (목표 시작일)
   - targetDate: Date (목표 달성 예정일)
   - createdAt, updatedAt: Date (timestamps)

✅ **Physical consistency validation:**
   - validatePhysicalConsistency() method
   - Checks: 목표 제지방량 ≥ 목표 근육량
   - Returns ValidationResult with error message
   - Per ERD requirement: 제지방량 ≥ 목표근육량 validation

### Bonus Features

✅ **Computed properties for convenience**
   - targetLeanBodyMass - 목표 제지방량 (kg)
   - startLeanBodyMass - 시작 제지방량 (kg)
   - targetWeightChange - 목표 체중 변화량 (kg)
   - durationInDays - 목표 기간 (일)
   - durationInWeeks - 목표 기간 (주)

✅ **Factory method for creation**
   - create() - Creates Goal with all required fields

✅ **Update methods for functional programming**
   - updatingTargets() - Updates target values with validation
   - updatingWeeklyRates() - Updates weekly change rates
   - updatingDailyCalorieTarget() - Updates calorie target
   - updatingActiveStatus() - Activates/deactivates goal
   - updatingTargetDate() - Updates target date

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows all key properties including computed values
   - Displays Korean labels for goal type and status

### Quality Attributes

✅ Follows established patterns from User, BodyRecord, DailyLog entities
✅ Korean documentation with 학습 포인트 (Goal Target Validation)
✅ Comprehensive doc comments with validation rules and formulas
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Functional update pattern (returns new instances)
✅ Validation prevents physically impossible goals

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Goal Target Validation pattern
- Compares to Bean Validation's custom validation logic
- Shows how Swift uses methods instead of annotations

**Key Concepts:**
- Physical consistency validation for body composition goals
- Lean body mass = weight - body fat mass
- Muscle mass is part of lean body mass (must be ≤ LBM)
- Weekly change rates for progress tracking
- Daily calorie target calculation from weekly goals
- Start values snapshot for progress comparison

**Validation Logic:**
```
목표 체지방량 = 목표 체중 × (목표 체지방률 / 100)
목표 제지방량 = 목표 체중 - 목표 체지방량
검증: 목표 근육량 ≤ 목표 제지방량

Example:
목표 체중 70kg, 목표 체지방률 10%
→ 목표 체지방량 = 70 × 0.1 = 7kg
→ 목표 제지방량 = 70 - 7 = 63kg
→ 목표 근육량은 최대 63kg까지만 가능
```

**Usage Examples:**
```swift
// 1. Create weight loss goal
let goal = Goal.create(
    userId: userId,
    goalType: .lose,
    targetWeight: 65.0,
    targetBodyFatPct: 15.0,
    targetMuscleMass: 30.0,
    weeklyWeightRate: -0.5,
    weeklyFatPctRate: -0.5,
    weeklyMuscleRate: 0.0,
    startWeight: 70.0,
    startBodyFatPct: 20.0,
    startMuscleMass: 30.0,
    startBMR: 1650,
    startTDEE: 2550,
    dailyCalorieTarget: 2000,
    targetDate: Date().addingTimeInterval(60 * 60 * 24 * 70)
)

// 2. Validate physical consistency
let validation = goal.validatePhysicalConsistency()
if !validation.isValid {
    print("오류: \(validation.errorMessage ?? "")")
}

// 3. Update targets with validation
if let updatedGoal = goal.updatingTargets(
    targetWeight: 68.0,
    targetBodyFatPct: 16.0,
    targetMuscleMass: 31.0
) {
    // Valid update - use updatedGoal
} else {
    // Invalid - physically impossible goal
}
```

### Git Status

- File committed in: 4f3229d
- Commit message: "auto-claude: 3.9 - Pure Swift struct for Goal with target validation"
- Implementation plan updated to "completed"
- Phase 3 status: 9/9 subtasks completed ✅
- **Phase 3 COMPLETED!**

### Architecture Notes

**Goal Target Validation:**
- Prevents physically impossible goals (muscle mass > lean body mass)
- Validates at creation and update time
- User-friendly Korean error messages
- Ensures data integrity before persistence

**Physical Consistency Rules:**
- Lean body mass includes: muscle, bones, organs, water
- Muscle mass is a subset of lean body mass
- Therefore: muscle mass ≤ lean body mass always
- Validation enforces this biological constraint

**Why Separate Start Values?**
- Snapshot approach: preserve goal starting point
- Calculate progress: current vs start vs target
- Track actual vs expected progress
- Handle goal updates without losing history

**Weekly Change Rates:**
- Enable realistic goal planning
- Calculate expected timeline
- Adjust daily calorie targets
- Monitor if progress matches plan

**Data Flow:**
1. User sets goal → create() with current body data as start values
2. System validates → validatePhysicalConsistency()
3. If valid → save to Core Data via GoalEntity
4. Track progress → compare current BodyRecord to start values
5. Adjust goal → updatingTargets() with validation

---

## Subtask 3.8: Create DailyLog Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/DailyLog.swift
**Commit:** 83d12c6

### Implementation Details

All acceptance criteria have been met:

✅ **DailyLog struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **Intake section: totalCaloriesIn, totalCarbs, totalProtein, totalFat, macro ratios**
   - totalCaloriesIn: Int (일일 총 섭취 칼로리)
   - totalCarbs: Decimal (일일 총 섭취 탄수화물)
   - totalProtein: Decimal (일일 총 섭취 단백질)
   - totalFat: Decimal (일일 총 섭취 지방)
   - Computed properties: carbsRatio, proteinRatio, fatRatio (%)

✅ **Metabolism section: bmr, tdee, netCalories**
   - bmr: Int (기초대사량, kcal/day)
   - tdee: Int (일일 총 에너지 소비량, kcal/day)
   - netCalories: Computed property (섭취 - 소모 - TDEE)

✅ **Exercise section: totalCaloriesOut, exerciseMinutes, exerciseCount, steps**
   - totalCaloriesOut: Int (일일 총 소모 칼로리)
   - exerciseMinutes: Int (일일 총 운동 시간)
   - exerciseCount: Int (일일 운동 횟수)
   - steps: Int? (일일 걸음 수, optional)

✅ **Body section: weight, bodyFatPct**
   - weight: Decimal? (당일 체중, optional)
   - bodyFatPct: Decimal? (당일 체지방률, optional)

✅ **Sleep section: sleepDuration, sleepStatus**
   - sleepDuration: Int? (일일 총 수면 시간, optional)
   - sleepStatus: SleepStatus? (수면 상태, optional)

### Bonus Features

✅ **Computed macro ratios with proper calorie conversion**
   - carbsRatio: (탄수화물g × 4kcal/g) / 총 섭취 칼로리 × 100
   - proteinRatio: (단백질g × 4kcal/g) / 총 섭취 칼로리 × 100
   - fatRatio: (지방g × 9kcal/g) / 총 섭취 칼로리 × 100

✅ **Factory method for initial creation**
   - empty(userId:date:) - Creates DailyLog with all aggregation values at 0 or nil

✅ **Update methods for functional programming**
   - withNutrition() - Updates intake section
   - withExercise() - Updates exercise section
   - withMetabolism() - Updates metabolism section
   - withBody() - Updates body section
   - withSleep() - Updates sleep section

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows all key sections with Korean labels
   - Displays computed values (netCalories, macro ratios)

### Quality Attributes

✅ Follows established patterns from SleepRecord, ExerciseRecord, FoodRecord entities
✅ Korean documentation with 학습 포인트 (Daily Aggregation Pattern)
✅ Comprehensive doc comments with calculation formulas
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Functional update pattern (returns new instances)

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Daily Aggregation Pattern
- Compares to JPA @Formula or View Entity
- DailyLog stores aggregated data for dashboard optimization

**Key Concepts:**
- Central entity for dashboard display
- Aggregates data from FoodRecord, ExerciseRecord, SleepRecord, BodyRecord
- One DailyLog per date per user (unique constraint)
- 02:00 sleep boundary logic applied to date
- Optimized for read-heavy dashboard queries

**Calculation Formulas:**
```
순 칼로리 = 섭취 칼로리 - 소모 칼로리 - TDEE
탄수화물 비율 = (totalCarbs × 4) / totalCaloriesIn × 100
단백질 비율 = (totalProtein × 4) / totalCaloriesIn × 100
지방 비율 = (totalFat × 9) / totalCaloriesIn × 100
```

**Usage Examples:**
```swift
// 1. Create empty DailyLog
let emptyLog = DailyLog.empty(userId: userId, date: Date())

// 2. Update with nutrition data
let withFood = emptyLog.withNutrition(
    totalCaloriesIn: 2000,
    totalCarbs: 250.0,
    totalProtein: 120.0,
    totalFat: 60.0
)

// 3. Update with exercise data
let withExercise = withFood.withExercise(
    totalCaloriesOut: 300,
    exerciseMinutes: 60,
    exerciseCount: 2
)

// 4. Check net calories
print(withExercise.netCalories) // -100 (deficit)
print(withExercise.carbsRatio) // 50.0%
```

### Git Status

- File committed in: 83d12c6
- Commit message: "auto-claude: 3.8 - Pure Swift struct for DailyLog (daily aggregation)"
- Implementation plan updated to "completed"
- Phase 3 status: 8/9 subtasks completed

### Architecture Notes

**Daily Aggregation Pattern:**
- DailyLog aggregates multiple Records for efficient dashboard queries
- Reduces need for complex joins and aggregations on every page load
- Updated when underlying Records change (FoodRecord, ExerciseRecord, etc.)
- Enables fast historical data retrieval

**Data Relationships:**
1. **FoodRecord (N:1):**
   - Multiple FoodRecords per date aggregate into DailyLog
   - DailyLog stores totalCaloriesIn, totalCarbs, totalProtein, totalFat

2. **ExerciseRecord (N:1):**
   - Multiple ExerciseRecords per date aggregate into DailyLog
   - DailyLog stores totalCaloriesOut, exerciseMinutes, exerciseCount

3. **SleepRecord (N:1):**
   - Multiple SleepRecords per date aggregate into DailyLog
   - DailyLog stores sleepDuration (sum), sleepStatus (primary sleep)

4. **BodyRecord (1:1):**
   - One BodyRecord per date links to DailyLog
   - DailyLog stores weight, bodyFatPct snapshots

5. **MetabolismSnapshot (1:1):**
   - One MetabolismSnapshot per date links to DailyLog
   - DailyLog stores bmr, tdee for calorie calculations

**Update Strategy:**
- When Record is created/updated/deleted → Recalculate DailyLog aggregates
- Use Repository pattern to handle cascading updates
- Ensures DailyLog always reflects current Record data

**Computed Properties:**
- netCalories: Real-time calculation (no storage needed)
- Macro ratios: Real-time calculation with proper calorie conversions
- Zero division handling (returns 0.0 if no intake)

**Why Separate Entity?**
- Performance: Dashboard loads one DailyLog instead of joining many Records
- Simplicity: ViewModels work with single aggregated entity
- Flexibility: Can add computed fields without changing Record entities
- Scalability: Fast queries even with thousands of Records

---

## Subtask 3.7: Create SleepRecord Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/SleepRecord.swift
**Commit:** ba178c1

### Implementation Details

All acceptance criteria have been met:

✅ **SleepRecord struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **All properties from ERD:**
   - id: UUID (unique identifier)
   - userId: UUID (foreign key to User)
   - date: Date (수면 날짜, 02:00 sleep boundary logic)
   - duration: Int (수면 시간, 분 단위)
   - status: SleepStatus enum (bad/soso/good/excellent/oversleep, auto-calculated)
   - createdAt: Date (creation timestamp)
   - updatedAt: Date (modification timestamp)

✅ **HealthKit integration properties:**
   - fromHealthKit: Bool (HealthKit 연동 여부)
   - healthKitId: String? (HealthKit 수면 고유 식별자, optional)

✅ **Auto-status calculation:**
   - Static SleepStatus.from(durationMinutes:) method for status determination
   - Status thresholds: bad<330, soso 330-389, good 390-449, excellent 450-540, oversleep>540
   - Automatic calculation in factory methods

✅ **02:00 sleep boundary logic:**
   - Date property uses logical date (not physical timestamp)
   - Documentation explains 02:00 boundary rule
   - 00:00-01:59 → previous day, 02:00-23:59 → current day

### Bonus Features

✅ **Factory methods for different creation scenarios**
   - create() - Manual sleep record (user input)
   - createFromHealthKit() - HealthKit integration record

✅ **Update method with status recalculation**
   - updatingDuration(_:) - Updates duration and recalculates status

✅ **Computed property for convenience**
   - durationInHours - Returns sleep duration in hours (Double)

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows all key properties including Korean display names
   - Indicates HealthKit source with [HealthKit] tag

### Quality Attributes

✅ Follows established patterns from ExerciseRecord and BodyRecord entities
✅ Korean documentation with 학습 포인트 (Auto-Status Calculation)
✅ Comprehensive doc comments with status determination thresholds
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Functional update pattern (returns new instances)

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Auto-Status Calculation pattern
- Compares to JPA @PrePersist for automatic calculation
- Shows how Swift uses factory methods instead of lifecycle hooks

**Key Concepts:**
- Sleep status determination based on duration
- Duration thresholds for sleep quality assessment
- HealthKit integration for automatic sleep tracking
- N:1 relationship with DailyLog for daily sleep totals
- 02:00 sleep boundary for date assignment

**Status Determination Thresholds:**
```
나쁨 (bad): 0-329분 (0-5.5시간)
보통 (soso): 330-389분 (5.5-6.5시간)
좋음 (good): 390-449분 (6.5-7.5시간)
매우 좋음 (excellent): 450-540분 (7.5-9시간)
과수면 (oversleep): 541분 이상 (9시간 초과)
```

**Usage Examples:**
```swift
// 1. Manual sleep record
let record = SleepRecord.create(
    userId: userId,
    date: Date(),
    duration: 420
)
// record.duration = 420분 (7시간)
// record.status = .good (자동 계산)

// 2. HealthKit integration
let healthKitRecord = SleepRecord.createFromHealthKit(
    userId: userId,
    date: Date(),
    duration: 480,
    healthKitId: "HK-SLEEP-12345"
)
// healthKitRecord.status = .excellent (자동 계산: 480분 = 8시간)
// healthKitRecord.fromHealthKit = true
```

### Git Status

- File committed in: ba178c1
- Commit message: "auto-claude: 3.7 - Pure Swift struct for SleepRecord with auto-status"
- Implementation plan updated to "completed"
- Phase 3 status: 7/9 subtasks completed

### Architecture Notes

**Auto-Status Calculation:**
- Sleep status automatically determined from duration
- SleepStatus.from(durationMinutes:) encapsulates logic
- Ensures consistent status determination across app
- No manual status selection needed from user

**02:00 Sleep Boundary Logic:**
- Sleep ending before 02:00 counts as previous day
- Matches natural sleep patterns (late night = previous day)
- DateUtils.getLogicalDate() provides this functionality
- Documentation clearly explains boundary behavior

**HealthKit Integration Pattern:**
- fromHealthKit flag distinguishes automatic vs manual records
- healthKitId prevents duplicate imports
- Supports both user-input and automatic sleep tracking
- Unified data model for all sleep sources

**Data Flow:**
1. Manual record: User inputs sleep duration → create() factory method → Auto-calculate status
2. HealthKit: Fetch from HealthKit → createFromHealthKit() → Auto-calculate status
3. Both records aggregate into DailyLog for daily sleep totals
4. Dashboard displays sleep duration and status

**Why Separate fromHealthKit?**
- Distinguish data sources for accuracy
- Prevent duplicate entries (user shouldn't edit HealthKit records)
- Enable selective data sync strategies
- Support mixed manual + automatic tracking

---

## Subtask 3.6: Create ExerciseRecord Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/ExerciseRecord.swift
**Commit:** 0b557cd

### Implementation Details

All acceptance criteria have been met:

✅ **ExerciseRecord struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **All properties from ERD:**
   - id: UUID (unique identifier)
   - userId: UUID (foreign key to User)
   - date: Date (운동 날짜, 02:00 sleep boundary logic)
   - exerciseType: ExerciseType enum (walking/running/cycling/swimming/weight/crossfit/yoga/other)
   - duration: Int (운동 시간, 분 단위, 1-480 range)
   - intensity: Intensity enum (low/medium/high)
   - caloriesBurned: Int (소모 칼로리, kcal, auto-calculated)
   - note: String? (운동 메모, optional)
   - createdAt: Date (creation timestamp)
   - updatedAt: Date (modification timestamp)

✅ **HealthKit integration properties:**
   - fromHealthKit: Bool (HealthKit 연동 여부)
   - healthKitId: String? (HealthKit 운동 고유 식별자, optional)

✅ **MET-based calorie calculation:**
   - Static calculateCaloriesBurned(exerciseType:intensity:duration:weight:) method
   - Formula: MET × weight(kg) × (duration/60)
   - MET values retrieved from ExerciseType.metValue(for: intensity.rawValue)
   - Automatic calculation in factory methods

### Bonus Features

✅ **Factory methods for different creation scenarios**
   - create() - Manual exercise record (user input)
   - createFromHealthKit() - HealthKit integration record

✅ **Update methods with calorie recalculation**
   - updatingDuration(_:weight:) - Updates duration and recalculates calories
   - updatingIntensity(_:weight:) - Updates intensity and recalculates calories
   - updatingNote(_:) - Updates note only

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows all key properties including Korean display names
   - Indicates HealthKit source with [HealthKit] tag

### Quality Attributes

✅ Follows established patterns from FoodRecord and BodyRecord entities
✅ Korean documentation with 학습 포인트 (MET-based Calorie Calculation)
✅ Comprehensive doc comments with calculation formulas
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Functional update pattern (returns new instances)

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains MET-based Calorie Calculation pattern
- Compares to JPA @PrePersist for automatic calculation
- Shows how Swift uses factory methods instead of lifecycle hooks

**Key Concepts:**
- MET (Metabolic Equivalent of Task) for exercise intensity measurement
- Calorie calculation: MET × weight × hours
- HealthKit integration for automatic exercise tracking
- N:1 relationship with DailyLog for daily exercise totals
- 02:00 sleep boundary for date assignment

**Calculation Formula:**
```
1. MET 값 조회: exerciseType.metValue(for: intensity.rawValue)
2. 운동 시간 변환: duration(분) / 60 = hours
3. 칼로리 계산: MET × weight(kg) × hours
```

**Usage Examples:**
```swift
// 1. Manual exercise record
let record = ExerciseRecord.create(
    userId: userId,
    date: Date(),
    exerciseType: .running,
    duration: 30,
    intensity: .medium,
    weight: 70.0,
    note: "아침 조깅"
)
// record.caloriesBurned = 280 kcal (자동 계산)

// 2. HealthKit integration
let healthKitRecord = ExerciseRecord.createFromHealthKit(
    userId: userId,
    date: Date(),
    exerciseType: .walking,
    duration: 45,
    intensity: .low,
    weight: 70.0,
    healthKitId: "HK-12345"
)
// healthKitRecord.fromHealthKit = true
```

### Git Status

- File committed in: 0b557cd
- Commit message: "auto-claude: 3.6 - Pure Swift struct for ExerciseRecord with calorie calculation"
- Implementation plan updated to "completed"
- Phase 3 status: 6/9 subtasks completed

### Architecture Notes

**MET-based Calorie Calculation:**
- MET (Metabolic Equivalent of Task) represents exercise intensity
- 1 MET = resting metabolic rate (约 1 kcal/kg/hour)
- Different exercise types have different MET values
- Intensity level (low/medium/high) affects MET value
- Formula ensures accurate calorie tracking

**HealthKit Integration Pattern:**
- fromHealthKit flag distinguishes automatic vs manual records
- healthKitId prevents duplicate imports
- Supports both user-input and automatic exercise tracking
- Unified data model for all exercise sources

**Data Flow:**
1. Manual record: User inputs exercise → create() factory method → Auto-calculate calories
2. HealthKit: Fetch from HealthKit → createFromHealthKit() → Auto-calculate calories
3. Both records aggregate into DailyLog for daily totals
4. Dashboard displays total exercise time and calories burned

**Why Separate fromHealthKit?**
- Distinguish data sources for accuracy
- Prevent duplicate entries (user shouldn't edit HealthKit records)
- Enable selective data sync strategies
- Support mixed manual + automatic tracking

---

## Subtask 3.5: Create FoodRecord Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/FoodRecord.swift
**Commit:** 829cb63

### Implementation Details

All acceptance criteria have been met:

✅ **FoodRecord struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **All properties from ERD:**
   - id: UUID (unique identifier)
   - userId: UUID (foreign key to User)
   - foodId: UUID (foreign key to Food, N:1 relationship)
   - date: Date (섭취 날짜, 02:00 sleep boundary logic)
   - mealType: MealType enum (breakfast/lunch/dinner/snack)
   - quantity: Decimal (섭취량)
   - quantityUnit: QuantityUnit enum (serving/gram)
   - createdAt: Date (creation timestamp)

✅ **CalculatedNutrition nested struct**
   - calories: Int (계산된 섭취 칼로리)
   - carbohydrates: Decimal (계산된 탄수화물)
   - protein: Decimal (계산된 단백질)
   - fat: Decimal (계산된 지방)
   - sodium: Decimal? (계산된 나트륨, optional)
   - fiber: Decimal? (계산된 식이섬유, optional)
   - sugar: Decimal? (계산된 당류, optional)

✅ **calculateNutrition(from:) method**
   - Takes Food parameter and calculates actual nutrition consumed
   - Formula: multiplier = quantity / Food.servingSize
   - Returns CalculatedNutrition with all values × multiplier
   - Uses Decimal.rounded(scale:) for proper rounding

### Bonus Features

✅ **Update methods for functional programming**
   - updatingQuantity(_:unit:) - Updates quantity and optionally unit
   - updatingMealType(_:) - Updates meal type classification

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows all key properties in formatted output
   - Displays mealType and quantityUnit with Korean names

### Quality Attributes

✅ Follows established patterns from Food and BodyRecord entities
✅ Korean documentation with 학습 포인트 (Transactional Record Pattern)
✅ Comprehensive doc comments with calculation formulas
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Functional update pattern (returns new instances)

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Transactional Record Pattern
- Compares to JPA @ManyToOne relationship (OrderItem - Product pattern)
- FoodRecord is transactional data that references Food master data

**Key Concepts:**
- N:1 relationship with Food (many records can reference same food)
- Aggregation into DailyLog for daily nutrition totals
- Meal type classification for pattern analysis
- Quantity-based nutrition calculation
- 02:00 sleep boundary for date assignment

**Calculation Formula:**
```
multiplier = quantity / Food.servingSize
섭취 칼로리 = Food.calories × multiplier
섭취 탄수화물 = Food.carbohydrates × multiplier
섭취 단백질 = Food.protein × multiplier
섭취 지방 = Food.fat × multiplier
```

**Usage Example:**
```swift
// 1. Select food and record intake
let rice = Food(name: "백미밥", calories: 130, servingSize: 100.0, ...)
let record = FoodRecord(
    userId: userId,
    foodId: rice.id,
    date: Date(),
    mealType: .lunch,
    quantity: 200.0,
    quantityUnit: .gram,
    ...
)

// 2. Calculate nutrition
let nutrition = record.calculateNutrition(from: rice)
// nutrition.calories = 260 kcal (130 × 2.0)
// nutrition.carbohydrates = 57.4g (28.7 × 2.0)
```

### Git Status

- File committed in: 829cb63
- Commit message: "auto-claude: 3.5 - Pure Swift struct for FoodRecord (meal log entry)"
- Implementation plan updated to "completed"
- Phase 3 status: 5/9 subtasks completed

### Architecture Notes

**Transactional Record Pattern:**
- FoodRecord stores actual consumption events
- References immutable Food master data
- Enables consistent nutrition calculations
- Supports meal pattern analysis

**Data Relationships:**
1. **Food (N:1):**
   - Many FoodRecords reference same Food
   - Food is master data, FoodRecord is transactional
   - Avoids duplicating nutrition information

2. **DailyLog (N:1):**
   - Multiple FoodRecords per date aggregate into DailyLog
   - DailyLog calculates daily nutrition totals
   - Grouped by date for dashboard display

**Calculation Strategy:**
- Client-side calculation for immediate feedback
- Server/Core Data stores raw quantity values
- Recalculate when Food nutrition data changes
- Flexible for future unit conversion support

---

## Subtask 3.4: Create Food Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/Food.swift
**Commit:** 050ec5d

### Implementation Details

All acceptance criteria have been met:

✅ **Food struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **Nutritional info: calories, carbs, protein, fat, sodium, fiber, sugar**
   - calories: Int (kcal, required)
   - carbohydrates: Decimal (g, required)
   - protein: Decimal (g, required)
   - fat: Decimal (g, required)
   - sodium: Decimal? (mg, optional - API may not provide)
   - fiber: Decimal? (g, optional - API may not provide)
   - sugar: Decimal? (g, optional - API may not provide)

✅ **Serving info: servingSize, servingUnit**
   - servingSize: Decimal (기준 제공량)
   - servingUnit: QuantityUnit? (.gram or .serving, optional)

✅ **Source tracking: source, apiCode, createdByUserId**
   - source: FoodSource enum (.kfdaAPI, .usdaAPI, .userCreated)
   - apiCode: String? (API 고유 코드, optional for user-created foods)
   - createdByUserId: UUID? (사용자 생성 음식의 생성자 ID, optional)

### Bonus Features

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows key nutritional info and source
   - Smart servingUnit display (shows displayName if present)

✅ **Master Data Pattern**
   - Immutable nutritional reference data
   - Referenced by multiple FoodRecord entries
   - Optimized for search and reuse

### Quality Attributes

✅ Follows established patterns from User, BodyRecord, MetabolismSnapshot entities
✅ Korean documentation with 학습 포인트 (learning points)
✅ Comprehensive doc comments with usage examples
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Detailed property documentation with value ranges

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Master Data Pattern
- Compares to JPA @OneToMany relationship (Product - OrderItem pattern)
- Food is immutable reference data referenced by many FoodRecord entries

**Key Concepts:**
- Master data vs transactional data separation
- Multiple data sources: KFDA API, USDA API, user-created
- Nutritional information per serving size
- Optional fields for incomplete API data
- Reusable food definitions for meal logging

**Usage Examples:**
```swift
// 1. API food (from KFDA)
let rice = Food(
    id: UUID(),
    name: "백미밥",
    calories: 130,
    carbohydrates: 28.7,
    protein: 2.5,
    fat: 0.2,
    sodium: 0,
    fiber: 0.3,
    sugar: 0.1,
    servingSize: 100.0,
    servingUnit: .gram,
    source: .kfdaAPI,
    apiCode: "KFDA_12345",
    createdByUserId: nil,
    createdAt: Date()
)

// 2. User-created food
let customMeal = Food(
    id: UUID(),
    name: "엄마표 된장찌개",
    calories: 120,
    servingSize: 1.0,
    servingUnit: .serving,
    source: .userCreated,
    apiCode: nil,
    createdByUserId: userId,
    ...
)
```

### Git Status

- File committed in: 050ec5d
- Commit message: "auto-claude: 3.4 - Pure Swift struct for Food master data"
- Implementation plan updated to "completed"
- Phase 3 status: 4/9 subtasks completed

### Architecture Notes

**Master Data Pattern:**
- Food entities are master data (reference data)
- Reused across multiple FoodRecord entries
- Immutable after creation (var for potential updates in Core Data sync)
- Optimized for search and selection in UI

**Data Sources:**
1. **KFDA API** (식품의약품안전처)
   - Korean food database
   - Official nutritional data
   - apiCode stores KFDA food code

2. **USDA API** (미국 농무부)
   - International food database
   - Comprehensive nutritional data
   - apiCode stores USDA food ID

3. **User Created**
   - Custom food entries
   - createdByUserId tracks creator
   - No apiCode (user-generated)

**Data Flow:**
1. API sync: Fetch food data from KFDA/USDA → Create Food entities
2. User creates: User inputs nutritional info → Create Food entity with .userCreated source
3. Meal logging: User selects Food → Create FoodRecord with quantity
4. Nutrition calculation: FoodRecord uses Food nutritional data × quantity

**Why Separate Entity from FoodRecord?**
- Avoid duplication: Same food used in multiple meals
- Data integrity: Nutritional info defined once
- Efficiency: Search and select from master data
- Updates: Fix nutritional data in one place affects all records (if needed)

---

## Subtask 3.3: Create MetabolismSnapshot Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/MetabolismSnapshot.swift
**Commit:** 527d6ce

### Implementation Details

All acceptance criteria have been met:

✅ **MetabolismSnapshot struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **All properties from ERD:**
   - id: UUID (unique identifier)
   - userId: UUID (foreign key to User)
   - bodyRecordId: UUID (foreign key to BodyRecord for 1:1 relationship)
   - date: Date (same as BodyRecord.date for 1:1 mapping)
   - weight: Decimal (snapshot of body weight at this point in time)
   - bodyFatPct: Decimal (snapshot of body fat percentage)
   - bmr: Int (calculated Basal Metabolic Rate in kcal/day)
   - tdee: Int (calculated Total Daily Energy Expenditure in kcal/day)
   - activityLevel: ActivityLevel enum (activity level used for TDEE calculation)
   - createdAt: Date (creation timestamp)

### Bonus Features

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows all key properties including calculations

### Quality Attributes

✅ Follows established patterns from User and BodyRecord entities
✅ Korean documentation with 학습 포인트 (learning points)
✅ Comprehensive doc comments with calculation formulas
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Immutable struct with let properties (snapshot pattern)

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains 1:1 Relationship Entity Pattern
- Compares to JPA @OneToOne relationship
- Shows how separate table optimizes historical queries

**Key Concepts:**
- 1:1 relationship with BodyRecord via same date value
- Snapshot pattern: preserves metabolism state at specific point in time
- Enables tracking metabolism changes over time for dashboard charts
- Automatic creation when BodyRecord is saved

**Calculation Formulas:**
```
BMR (Mifflin-St Jeor equation):
  Male: (10 × weight) + (6.25 × height) - (5 × age) + 5
  Female: (10 × weight) + (6.25 × height) - (5 × age) - 161

TDEE:
  TDEE = BMR × activityLevel.multiplier
```

**Usage Example:**
```swift
let snapshot = MetabolismSnapshot(
    id: UUID(),
    userId: userId,
    bodyRecordId: bodyRecord.id,
    date: bodyRecord.date,
    weight: 70.0,
    bodyFatPct: 18.5,
    bmr: 1650,
    tdee: 2550,
    activityLevel: .moderate,
    createdAt: Date()
)
```

### Git Status

- File committed in: 527d6ce
- Commit message: "auto-claude: 3.3 - Pure Swift struct for MetabolismSnapshot (1:1 with BodyRecord)"
- Implementation plan updated to "completed"
- Phase 3 status: 3/9 subtasks completed

### Architecture Notes

**1:1 Relationship Pattern:**
- MetabolismSnapshot and BodyRecord share the same date value
- When BodyRecord is saved, MetabolismSnapshot is automatically created
- Separate entity optimizes queries for metabolism history charts
- Snapshot pattern preserves point-in-time metabolism data

**Data Flow:**
1. User enters body data → BodyRecord created
2. BMR/TDEE calculated using User profile data
3. MetabolismSnapshot created with same date as BodyRecord
4. Both entities saved in same transaction
5. Dashboard queries MetabolismSnapshot for metabolism trends

**Why Separate Entity?**
- Performance: Querying metabolism trends doesn't require loading body composition data
- Clarity: Separates concerns (body data vs metabolism calculations)
- Flexibility: Can query metabolism changes independently
- Optimization: Indexed date column for fast time-range queries

---

## Subtask 3.1: Create User Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/User.swift
**Commit:** b23dd39

### Implementation Details

All acceptance criteria have been met:

✅ **User struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **All properties from ERD:**
   - id: UUID (unique identifier)
   - name: String (1-20 chars validated)
   - gender: Gender enum (male/female)
   - birthDate: Date (used for age calculation)
   - height: Decimal (100-250cm range)
   - activityLevel: ActivityLevel enum (sedentary to veryActive)

✅ **Current values:**
   - currentWeight: Decimal (20-300kg)
   - currentBodyFatPct: Decimal (3-60%)
   - currentMuscleMass: Decimal (10-60kg)
   - currentBMR: Int (calculated via Mifflin-St Jeor)
   - currentTDEE: Int (BMR × activityLevel.multiplier)

✅ **Timestamps:**
   - metabolismUpdatedAt: Date (when metabolism was last calculated)
   - createdAt: Date (user creation timestamp)
   - updatedAt: Date (last modification timestamp)

✅ **Computed age property:**
   - Uses Date.age(from: birthDate) extension
   - Automatically calculates current age from birth date
   - Returns Int representing 만 나이 (Korean age system)

### Bonus Features

✅ **CustomStringConvertible protocol**
   - Provides readable debug description
   - Shows key properties in formatted output

### Quality Attributes

✅ Follows established patterns from Phase 1 & 2
✅ Korean documentation with 학습 포인트 (learning points)
✅ Comprehensive doc comments with usage examples
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Clean Architecture principles applied

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Domain Entity Pattern
- Compares to Clean Architecture in Java/JPA
- Separates business logic from persistence

**Property Documentation:**
- BMR calculation formula: (10 × weight) + (6.25 × height) - (5 × age) + gender constant
- TDEE calculation: BMR × activityLevel.multiplier
- Validation ranges for all numeric properties
- References ValidationService for input validation

**Usage Example:**
```swift
let user = User(
    id: UUID(),
    name: "홍길동",
    gender: .male,
    birthDate: Date(),
    height: 175.0,
    activityLevel: .moderate,
    currentWeight: 70.0,
    currentBodyFatPct: 18.5,
    currentMuscleMass: 32.0,
    currentBMR: 1650,
    currentTDEE: 2550,
    metabolismUpdatedAt: Date(),
    createdAt: Date(),
    updatedAt: Date()
)
print(user.age) // Automatically calculated
```

### Git Status

- File committed in: b23dd39
- Commit message: "auto-claude: 3.1 - Create User domain entity with all properties and computed age"
- Implementation plan updated to "completed"
- Phase 3 status updated to "in_progress" (1/9 subtasks done)

### Architecture Notes

**Domain Entity Pattern:**
- Pure Swift struct (no Core Data dependencies)
- Used in business logic layer (ViewModels, Services)
- Mapped to/from Core Data via UserEntity+Extensions (Phase 4)
- Improves testability (no NSManagedObject complexity)
- Better separation of concerns

**Data Flow:**
1. Core Data: UserEntity (persistent storage)
2. Extensions: UserEntity+Extensions (mapping layer)
3. Domain: User struct (business logic)
4. ViewModels: Use User struct for presentation logic

---

**Phase 3 Progress:** ✅ COMPLETED (9/9 subtasks)
- 3.1: User ✅
- 3.2: BodyRecord ✅
- 3.3: MetabolismSnapshot ✅
- 3.4: Food ✅
- 3.5: FoodRecord ✅
- 3.6: ExerciseRecord ✅
- 3.7: SleepRecord ✅
- 3.8: DailyLog ✅
- 3.9: Goal ✅

**Overall Progress:** Phase 1 (✅ Complete), Phase 2 (✅ Complete), Phase 3 (✅ Complete)
**Next Phase:** Phase 4 - Core Data Entity Extensions
**Next Subtask:** 4.1 - Create UserEntity+Extensions

---

## Subtask 3.2: Create BodyRecord Domain Entity - ✅ COMPLETED

**Status:** COMPLETED
**File:** Bodii/Domain/Entities/BodyRecord.swift
**Commit:** 8cc9c38

### Implementation Details

All acceptance criteria have been met:

✅ **BodyRecord struct with Identifiable, Codable, Equatable**
   - Identifiable: Uses UUID as id
   - Codable: All properties are Codable-conforming types
   - Equatable: Auto-synthesized by compiler

✅ **All properties from ERD:**
   - id: UUID (unique identifier)
   - userId: UUID (foreign key to User)
   - date: Date (unique per day, maps to MetabolismSnapshot)
   - weight: Decimal (20-300kg range)
   - bodyFatMass: Decimal (kg, auto-calculated from bodyFatPercent)
   - bodyFatPercent: Decimal (3-60%, auto-calculated from bodyFatMass)
   - muscleMass: Decimal (10-60kg range)
   - createdAt: Date (creation timestamp)

✅ **Helper methods for bodyFatMass ↔ bodyFatPercent calculation:**
   - Static calculateBodyFatMass(weight:bodyFatPercent:) - Formula: weight × (bodyFatPercent/100)
   - Static calculateBodyFatPercent(weight:bodyFatMass:) - Formula: (bodyFatMass/weight) × 100
   - Factory method from(userId:date:weight:bodyFatPercent:muscleMass:) - Creates record with auto-calculated bodyFatMass
   - Factory method from(userId:date:weight:bodyFatMass:muscleMass:) - Creates record with auto-calculated bodyFatPercent
   - updatingWeight(_:) - Recalculates bodyFatMass when weight changes
   - updatingBodyFatPercent(_:) - Recalculates bodyFatMass when bodyFatPercent changes
   - updatingBodyFatMass(_:) - Recalculates bodyFatPercent when bodyFatMass changes

### Bonus Features

✅ **Computed leanBodyMass property**
   - Formula: weight - bodyFatMass
   - Used for validation: muscleMass ≤ leanBodyMass

✅ **CustomStringConvertible protocol**
   - Provides readable debug description with all properties
   - Shows computed leanBodyMass value

### Quality Attributes

✅ Follows established patterns from User.swift
✅ Korean documentation with 학습 포인트 (learning points)
✅ Comprehensive doc comments with calculation formulas
✅ MARK organization for code sections
✅ Domain entity pattern (separated from Core Data)
✅ No console.log/print debugging statements
✅ Immutable by default with functional update methods

### Documentation Highlights

**학습 포인트 (Learning Point):**
- Explains Auto-calculation Logic pattern
- Compares to JPA @PrePersist/@PreUpdate hooks
- Shows how Swift uses helper methods instead

**Calculation Formulas:**
```
체지방량(kg) = 체중(kg) × (체지방률(%) / 100)
체지방률(%) = (체지방량(kg) / 체중(kg)) × 100
제지방량(kg) = 체중(kg) - 체지방량(kg)
```

**Usage Examples:**
- Creating record from bodyFatPercent (auto-calculates bodyFatMass)
- Creating record from bodyFatMass (auto-calculates bodyFatPercent)
- Updating individual values while maintaining consistency

### Git Status

- File committed in: 8cc9c38
- Commit message: "auto-claude: 3.2 - Pure Swift struct for BodyRecord with auto-calculation logic"
- Implementation plan updated to "completed"
- Phase 3 status: 2/9 subtasks completed

### Architecture Notes

**Auto-calculation Pattern:**
- Factory methods ensure calculations happen at creation time
- Update methods return new instances (functional approach)
- Static helpers can be used by Core Data extensions
- Prevents invalid states (bodyFatMass and bodyFatPercent always consistent)

**1:1 Relationship with MetabolismSnapshot:**
- Same date value links to MetabolismSnapshot
- When BodyRecord is saved, MetabolismSnapshot is auto-created
- Both entities track the same body composition snapshot

---
