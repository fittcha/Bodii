# Build Progress - Korean Food Database Integration

## Completed Subtasks

### Phase 3: USDA API Integration

#### 3.3 - USDA to Food entity mapper ✅ (2026-01-12)
- **Status**: COMPLETED
- **Commit**: ac228cf
- **Implementation**: Created USDAFoodMapper.swift with comprehensive DTO to domain entity mapping

**Key Features:**
- Maps USDA nutrient IDs to Food entity fields (energy: 1008, protein: 1003, fat: 1004, carbs: 1005, sodium: 1093, fiber: 1079, sugar: 2000)
- Comprehensive unit conversion system supporting 10+ unit types (oz, lb, kg, mg, ml, fl oz, cup, tbsp, tsp)
- Graceful handling of missing nutrients (required throw errors, optional return nil)
- Sets source to .usda and stores fdcId as apiCode
- Batch mapping capability with toDomainArray()
- Follows project patterns with Korean documentation

**Acceptance Criteria Met:**
✅ Maps USDA nutrient IDs to correct fields
✅ Converts units (oz to g, etc.) if needed
✅ Sets source to .usda
✅ Stores fdcId as apiCode
✅ Handles missing nutrients gracefully

**Files Created:**
- Bodii/Data/Mappers/USDAFoodMapper.swift (344 lines)

---

### Phase 4: Unified Search Service

#### 4.1 - Define FoodSearchRepository protocol ✅ (2026-01-12)
- **Status**: COMPLETED
- **Commit**: a8cebe3
- **Implementation**: Created FoodSearchRepository protocol for food search operations following clean architecture

**Key Features:**
- Protocol defines searchFoods() method with async/throws support
- Supports search query with optional parameters (limit, offset, useCache)
- Returns array of Food domain entities
- Follows dependency inversion principle (domain defines protocol, data implements)
- Cache management methods: getRecentFoods(), updateFoodAccessTime(), cleanupCache()
- Protocol extension with default parameter values for convenience
- FoodSearchError enum for domain-level error handling with localized messages

**Acceptance Criteria Met:**
✅ Protocol defines search method with async/throws
✅ Supports search query and optional parameters
✅ Returns array of Food domain entities
✅ Follows dependency inversion principle

**Files Created:**
- Bodii/Domain/Interfaces/FoodSearchRepository.swift (254 lines)

**Architecture:**
- Domain layer defines the contract (protocol)
- Data layer will implement the concrete class
- Repository pattern abstracts data sources (KFDA API, USDA API, local cache)
- Enables clean separation of concerns and testability

---

#### 4.2 - Implement UnifiedFoodSearchService ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: 3ae237f
- **Implementation**: Created UnifiedFoodSearchService for multi-source food search

**Key Features:**
- Intelligent search strategy based on query language (Korean vs English)
- Korean queries: KFDA API first → USDA fallback if < 5 results
- English queries: Parallel search (KFDA + USDA) using async let
- Result deduplication by apiCode or name
- Graceful error handling (returns results from successful API even if other fails)
- containsKoreanCharacters() helper for Unicode-based Korean detection
- Mock service included for testing

**Acceptance Criteria Met:**
✅ Searches 식약처 API first (primary)
✅ Falls back to USDA if no Korean results or search appears international
✅ Korean foods appear first in results
✅ Handles concurrent API calls efficiently
✅ Deduplicates results if same food from multiple sources
✅ Returns empty array gracefully if both APIs fail

**Files Created:**
- Bodii/Data/DataSources/Remote/UnifiedFoodSearchService.swift (378 lines)

---

#### 4.3 - Implement FoodSearchRepositoryImpl ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: 3692782
- **Implementation**: Created FoodSearchRepositoryImpl implementing FoodSearchRepository protocol

**Key Features:**
- Implements FoodSearchRepository protocol from domain layer
- Uses UnifiedFoodSearchService for multi-source API search
- Cache-first strategy with FoodLocalDataSource placeholder
- Full dependency injection support for testability
- searchFoods(): Input validation, cache check, API search, result caching
- getRecentFoods(): Cache-only query for recent foods
- updateFoodAccessTime(): Updates LRU cache timestamps
- cleanupCache(): Implements cache eviction policy
- Graceful error handling with FoodSearchError mapping
- MockFoodSearchRepository included for unit testing

**Acceptance Criteria Met:**
✅ Implements FoodSearchRepository protocol
✅ Uses UnifiedFoodSearchService for actual search
✅ Can be injected via DIContainer
✅ Testable with mock service

**Files Created:**
- Bodii/Data/Repositories/FoodSearchRepositoryImpl.swift (421 lines)

**Architecture:**
- Repository Pattern: Abstracts data sources (KFDA API, USDA API, local cache)
- Dependency Injection: Constructor injection with default parameters
- Clean Architecture: Domain defines protocol, Data implements
- Testability: Mock repository with call tracking

**Note:**
- FoodLocalDataSource defined as protocol placeholder
- Will be implemented in Phase 5 with Core Data
- Repository gracefully handles missing local data source

---

## Phase 5: Local Caching & Offline Support

#### 5.1 - Create FoodEntity for Core Data ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: b46ba7d
- **Implementation**: Updated Core Data model and created FoodEntity+CoreData.swift extension

**Key Features:**
- Updated Food entity in Core Data model with cache-specific fields:
  * `lastAccessedAt` (Date, optional) - for LRU (Least Recently Used) cache tracking
  * `searchCount` (Integer 32, default 0) - for popularity tracking
- Added four fetch indices for efficient queries:
  * `byApiCode` - for deduplication and lookup by API code
  * `byLastAccessed` - for LRU cache queries (descending order)
  * `byName` - for search by food name
  * `bySearchCount` - for popularity-based sorting (descending order)
- Created comprehensive FoodEntity+CoreData.swift extension (415 lines):
  * Cache management methods: isRecentlyAccessed, isPopular(), updateAccessTime(), isCacheExpired()
  * Domain entity conversion: toDomainEntity(), from(), update()
  * Fetch request builders: fetchRequest(), fetchRequestByApiCode(), fetchRecentFoods(), fetchPopularFoods(), fetchByName(), fetchExpiredCache()
  * Batch operations: batchCreate(), saveUnique() with upsert logic
  * Debug helpers for testing

**Acceptance Criteria Met:**
✅ Core Data entity matches Food domain model - All fields mapped correctly
✅ Includes lastAccessedAt for recency tracking - Added as optional Date attribute
✅ Includes searchCount for popularity - Added as Integer 32 with default 0
✅ Proper indices for efficient queries - Four indices added (apiCode, lastAccessed, name, searchCount)

**Files Created/Modified:**
- Bodii/Infrastructure/Persistence/Bodii.xcdatamodeld/Bodii.xcdatamodel/contents (updated)
- Bodii/Data/DataSources/Local/Entities/FoodEntity+CoreData.swift (415 lines)

**Architecture:**
- Follows Clean Architecture with clear separation of concerns
- Core Data entity (Infrastructure) ↔ Domain entity (Domain) conversion
- Extension pattern used to avoid modifying auto-generated Core Data classes
- Factory methods and convenience initializers for easy entity creation

**Cache Strategy:**
- LRU (Least Recently Used) based on lastAccessedAt timestamp
- Popularity tracking with searchCount for trending foods
- Automatic expiration after 30 days (configurable)
- Upsert logic to prevent duplicate API data

---

#### 5.2 - Implement FoodLocalDataSource ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: 5b94c0f
- **Implementation**: Created FoodLocalDataSourceImpl for local caching with Core Data

**Key Features:**
- FoodLocalDataSourceImpl.swift implementing FoodLocalDataSource protocol (465 lines)
- CRUD operations for cached food items:
  * searchFoods() - Name-based search with CONTAINS[cd] predicate for case-insensitive matching
  * getRecentFoods() - LRU cache query sorted by lastAccessedAt (descending)
  * saveFoods() - Upsert with deduplication by apiCode using Food.saveUnique()
  * updateAccessTime() - Activity tracking for LRU cache (updates lastAccessedAt and increments searchCount)
  * cleanupOldFoods() - Two-stage cache eviction (expired items + LRU-based cleanup)
- Async/await support wrapping Core Data synchronous APIs with context.perform()
- Uses FoodEntity+CoreData extension methods for optimized fetch requests
- Dependency injection with PersistenceController for testability
- Comprehensive error handling with FoodLocalDataSourceError enum (5 error types)
- MockFoodLocalDataSource for unit testing with call tracking

**Caching Strategy:**
- LRU (Least Recently Used) based on lastAccessedAt timestamp
- Popularity tracking with searchCount for trending foods
- Automatic expiration: 30-day cache lifetime for API data
- Deduplication: Uses apiCode to prevent duplicate storage from APIs
- Size limit: Default 500 items (configurable via maxCount parameter)

**Cache Cleanup Policy:**
1. Delete expired cache (30+ days old API data from governmentAPI and USDA sources)
2. Delete oldest items by lastAccessedAt if cache exceeds maxCount (LRU eviction)

**Error Handling:**
- FoodLocalDataSourceError enum with localized Korean messages:
  * fetchFailed(Error) - Cache query failures
  * saveFailed(Error) - Cache save/upsert failures
  * updateFailed(Error) - Access time update failures
  * deleteFailed(Error) - Cache deletion failures
  * conversionFailed(String) - Core Data to Domain entity conversion failures
- Proper error propagation from Core Data layer to domain layer

**Acceptance Criteria Met:**
✅ Save food to local cache - saveFoods() with Food.saveUnique() upsert logic
✅ Fetch recent foods (sorted by lastAccessedAt) - getRecentFoods() with LRU sorting
✅ Search cached foods by name - searchFoods() with CONTAINS[cd] predicate
✅ Update access timestamp on retrieval - updateAccessTime() with searchCount increment
✅ Delete old cached items (LRU cleanup) - cleanupOldFoods() with 2-stage eviction
✅ Limit cache to reasonable size (e.g., 500 items) - Default 500, configurable

**Files Created:**
- Bodii/Data/DataSources/Local/FoodLocalDataSource.swift (465 lines)

**Files Updated:**
- Bodii/Data/Repositories/FoodSearchRepositoryImpl.swift (protocol comment clarification)

**Architecture:**
- Data Layer implementation of local data source protocol
- Uses Core Data FoodEntity from Infrastructure Layer
- Follows Clean Architecture with proper layer separation
- Repository Pattern compatible (used by FoodSearchRepositoryImpl)
- NSManagedObjectContext.perform() for async/await compatibility

---

#### 5.3 - Create Food domain to Core Data mapper ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: d42d004
- **Implementation**: Created FoodEntityMapper for bidirectional mapping between Food domain entity and FoodEntity Core Data object

**Key Features:**
- Bidirectional mapping struct following mapper pattern (337 lines):
  * toDomain(from: FoodEntity) - Core Data → Domain conversion
  * toEntity(from: Food, context:) - Domain → Core Data conversion
  * update(entity:from:) - Update existing FoodEntity from Food
- Batch operations for efficient bulk processing:
  * toDomainArray(from: [FoodEntity]) - Bulk Core Data → Domain
  * toEntityArray(from: [Food], context:) - Bulk Domain → Core Data
- Upsert operations for cache deduplication:
  * saveUnique(from: [Food], context:) - Batch upsert by apiCode
  * saveUnique(domainFood: Food, context:) - Single item upsert
- Convenience methods:
  * toEntityAndSave() - Combines toEntity() + context.save()
- Delegates to FoodEntity+CoreData.swift extension methods for actual logic
- Provides clean, consistent interface matching KFDAFoodMapper and USDAFoodMapper patterns

**Field Mapping:**
- All required fields: id, name, calories, carbohydrates, protein, fat, servingSize, source, createdAt
- All optional fields: sodium, fiber, sugar, servingUnit, apiCode, createdByUserId
- Cache-specific fields: lastAccessedAt, searchCount (managed by FoodEntity methods)
- Type conversions: FoodSource enum ↔ Int16 rawValue, Decimal ↔ NSDecimalNumber

**Acceptance Criteria Met:**
✅ Maps Food to FoodEntity (Core Data) - toEntity() and batch methods
✅ Maps FoodEntity to Food (domain) - toDomain() and batch methods
✅ Handles all fields including optionals - Complete bidirectional mapping with nil handling
✅ Preserves source and apiCode - Both fields maintained in conversions

**Files Created:**
- Bodii/Data/Mappers/FoodEntityMapper.swift (337 lines)

**Architecture:**
- Follows mapper pattern consistent with KFDAFoodMapper and USDAFoodMapper
- Delegates to FoodEntity+CoreData.swift for implementation details
- Provides clean, consistent interface for Repository layer usage
- Maintains separation between Domain and Infrastructure layers
- Usage restricted to Data layer (Repository implementations)

**Documentation:**
- Comprehensive Korean documentation with Java comparison comments
- Usage examples for common scenarios (cache read/write, single/batch operations)
- Architectural guidelines for proper usage in Repository layer
- Educational comments explaining Clean Architecture layer separation

---

#### 5.4 - Integrate caching into search flow ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: c3903c4
- **Implementation**: Integrated comprehensive caching in FoodSearchRepositoryImpl

**Key Features:**
- Offline Fallback Strategy: When API search fails, automatically falls back to cached results
- Cache-First Strategy: Checks local cache before making API calls (when useCache=true)
- Auto-Caching: API search results are automatically cached in background via Task
- Error Handling: Graceful handling of both API and cache failures with debug logging

**Multi-tier Search Strategy:**
1. Tier 1: Check cache first if useCache=true
2. Tier 2: Search via UnifiedFoodSearchService (KFDA + USDA APIs)
3. Tier 3: Background cache update for API results
4. Tier 4: Offline fallback - return cached results on API failure

**Acceptance Criteria Met:**
✅ Check local cache before API call for exact matches
✅ Cache new foods from API results
✅ Return cached results when offline
✅ Show recent foods section from cache
✅ Update lastAccessedAt when food is selected

**Files Modified:**
- Bodii/Data/Repositories/FoodSearchRepositoryImpl.swift (added 36 lines)

**Offline Support:**
- Network failures gracefully handled with Circuit Breaker + Cache Fallback pattern
- Users can search previously-viewed foods even without internet
- Debug logging for development and troubleshooting

---

## Phase 6: Serving Size & Nutrition Calculation

#### 6.1 - Create NutritionCalculator utility ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: d636f7c
- **Implementation**: Created NutritionCalculator utility for calculating nutrition values based on serving size adjustments

**Key Features:**
- Main calculation method: calculate(from:quantity:unit:) returns CalculatedNutrition
- Multiplier calculation logic:
  * `.serving` unit: quantity is multiplier (1.5 servings = 1.5x)
  * `.grams` unit: (quantity / servingSize) is multiplier (300g / 210g = 1.43x)
- Nutrient calculation helpers:
  * calculateCalories() - rounds to Int32
  * calculateMacro() - rounds to 1 decimal place
  * calculateMacroRatios() - computes carbs/protein/fat percentages based on calorie contribution
- Convenience methods:
  * calculateForServings() - shorthand for serving-based calculation
  * calculateForGrams() - shorthand for gram-based calculation

**Supporting Types:**
- CalculatedNutrition struct: holds computed nutrition with quantity/unit context
  * toFoodRecord() helper method for easy FoodRecord creation
  * All nutrition fields: calories, carbs, protein, fat, sodium, fiber, sugar
  * Macro ratio percentages: carbsPercentage, proteinPercentage, fatPercentage
- MacroRatios struct: holds carbs/protein/fat percentage breakdown
- Constants.MacroNutrients extension: defines calorie conversion constants (4/4/9 kcal/g)

**Acceptance Criteria Met:**
✅ Calculate nutrition for given quantity and unit
✅ Support both serving-based and gram-based calculations
✅ Handle decimal precision appropriately
✅ Calculate macro ratios (carbs/protein/fat percentages)

**Files Created:**
- Bodii/Shared/Utils/NutritionCalculator.swift (441 lines)

**Documentation:**
- Comprehensive Korean documentation with usage examples
- Educational comments comparing to Java patterns
- Detailed calculation logic documentation
- Example usage for common scenarios

---

#### 6.2 - Create FoodWithQuantity model ✅ (2026-01-13)
- **Status**: COMPLETED
- **Commit**: 302aa9e
- **Implementation**: Created FoodWithQuantity domain entity for representing food with user-selected quantity

**Key Features:**
- Core Properties:
  * food: Food - Reference to base food entity
  * quantity: Decimal - User-selected quantity
  * unit: QuantityUnit - serving or grams
- Calculated Nutrition (Computed Properties):
  * calculatedNutrition: Full CalculatedNutrition struct
  * calculatedCalories, calculatedCarbohydrates, calculatedProtein, calculatedFat
  * calculatedSodium, calculatedFiber, calculatedSugar (optional)
  * carbsPercentage, proteinPercentage, fatPercentage
- Convenience Initializers:
  * withServings() - Create with serving unit
  * withGrams() - Create with gram unit
- FoodRecord Conversion:
  * toFoodRecord() - Convert to FoodRecord for saving to diary
  * toFoodRecordUsingCalculation() - Alternative using CalculatedNutrition helper
- Quantity Adjustment:
  * withQuantity() - Return new instance with updated quantity
  * withQuantity(_:unit:) - Return new instance with updated quantity and unit
- Display Helpers:
  * quantityDisplay - "1.5인분" or "300g"
  * fullDisplay - "현미밥 1.5인분"
- Protocol Conformance:
  * Identifiable (uses food.id)
  * Equatable (compares food, quantity, unit)
  * Hashable (combines all properties)

**Architecture:**
- Domain layer entity for UI and business logic
- Value type (struct) for immutability and safety
- Computed properties ensure calculations are always current
- No stored calculated values - always fresh from NutritionCalculator

**Use Cases:**
- Food search results with quantity selection
- Meal planning and nutrition preview
- Pre-commit validation before creating FoodRecord
- Nutrition simulation and "what-if" scenarios

**Acceptance Criteria Met:**
✅ Contains Food reference and quantity/unit
✅ Provides calculated nutrition properties
✅ Immutable calculated values based on quantity
✅ Easy to convert to FoodRecord

**Files Created:**
- Bodii/Domain/Entities/FoodWithQuantity.swift (426 lines)

**Documentation:**
- Comprehensive Korean documentation with usage examples
- Java DTO/VO pattern comparison comments
- Detailed examples for all major features
- Clear architectural guidelines

---

## Next Steps
- Phase 7: Error Handling & Resilience
  - 7.1: Create FoodSearchError enum
  - 7.2: Implement graceful fallback in search service
